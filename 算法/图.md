### 0x00 图

图是一种抽象数据类型（ADT），是一种由有限个结点（node或vertex）和边（edge）组成的非线性数据结构。一个图由顶点集（set of vertices）V和边集（set of edges）E组成，记为G=(V, E)。如下图就是由顶点集V={0, 1, 2, 3, 4}和边集E={01, 04, 14, 12, 13, 23, 34}组成。

![](https://www.geeksforgeeks.org/wp-content/uploads/undirectedgraph.png)

> 注意：线性表可以是空表，树可以是空树，但是**图不可以是空图**，也就是说，图中不能一个顶点都没有，**图的边集可以为空，但是图的顶点集一定不为空**。

图这种数据结构蛮有用的，比如上面的图可以表示一幅人际关系网，每个结点可以表示一个人，也可以表示城市道路的交通网等等。

### 0x01 图的种类

#### 0x00 有向图

有向图（Directed graph或digraph），是图中用来连接各顶点的边带有方向的图。又有定义，边集E是有向边（也成为弧）的有限集合时所构成的图，如图：

![](https://upload.wikimedia.org/wikipedia/commons/8/89/4-tournament.svg)

上图可表示为：
$$
G_1=(V_1, E_1) \\
V_1=\{1,2,3,4\} \\
E_1=\{<1,2>,<1,4>,<2,4>,<3,1>,<3,2>,<4,3>\}
$$

> 注：在国外教材中，有向图的边集一般用字母$A$来表示，$A$为arrow的首字母

其中在边集中我们用<V, W>来表示一条弧（arrows, directed edges, directed arcs或直接写为arc），这是一个**有序组**（ordered pairs），其中V和W为顶点，V称为弧尾（箭头的出发点, 英文讲叫做the tail of the arrow），W称为弧头（箭头所指向的点，英文讲为the head），这条弧称为从顶点V到W的弧（a path leads from V to W），也称V邻接到W。

#### 0x01 无向图

与有向图相反的是，无向图（undirected graph）即为边没有方向的图，在边集中，每一条边是用**无序组**（unordered pairs）(V, W)来表示的，故边(V, W)和边(W, V)是完全相同的。如图：

![](https://upload.wikimedia.org/wikipedia/commons/5/5b/6n-graf.svg)

上图可表示为：
$$
G_2=(V_2, E_2) \\
V_2=\{1,2,3,4,5,6\} \\
E_2=\{<1,2>,<1,5>,<2,3>,<2,5>,<3,4>,<4,5>,<4,6>\}
$$

#### 0x02 连通图

连通图（connected graph）：在无向图中，若从顶点v到顶点w有**路径**存在，则称v和w是连通的，若图中任意两个顶点都是连通的，则称此图为连通图。否则称为非连通图（disconnected graph）。如果一个图有N个结点，并且有小于N-1条边，则此图必为非连通图。**一个仅有一个顶点的图是连通图**。下图中，若把顶点0考虑在内，整个图不是连通图，除去0之外的部分为连通图：

![](https://upload.wikimedia.org/wikipedia/commons/9/97/UndirectedDegrees.svg)

无向图中的**极大连通子图**（maximal connected subgraph）称为**连通分量**（connected component）。相反还有极小连通子图（minimal connected subgraph），极小连通子图既要保持图连通又要是边数最小的子图。

强连通图（strongly connected graph）：如果在有向图中，从任意顶点v和任意顶点w之间都存在从v到w的路径和从w到v的路径，那么称此图为强连通图。下图中阴影部分的子图为强连通图：

![](https://upload.wikimedia.org/wikipedia/commons/5/5c/Scc.png)

有向图中的极大强连通子图称为有向图的强连通分量。

> TL;DR
>
> 由顶点集$V_1=\{a,b,e\}$和顶点集$V_2=\{f,g\}$共同构成的图不是强连通图，原因如下：从顶点b出发可以经过路径`bfg`抵达顶点g，但是从顶点g出发却没有一条路径可以抵达顶点b，所以顶点b和顶点g直接不是强连通的，所以由顶点集$V=V_1\bigcup V_2$构成的图不为强连通图。

#### 0x03 其他图

简单图（simple graph或strict graph）：一个图G中如果**不存在重复边**，**不存在从顶点到自身的边**，则为简单图。与之相对的则为多重图（Multigraph）。

无向完全图（complete graph）：如果图的任意两个节点之间都存在边，则称该图位无向完全图，如下：

![](https://upload.wikimedia.org/wikipedia/commons/2/2d/4-simplex_graph.svg)

含有$N$个顶点的无向完全图有$\frac{N(N-1)}{2}$条边。

有向完全图（complete digraph）：如果在有向图中，**任意两个顶点都存在方向相反的两条弧**，那么该图位有向完全图。

子图（subgraph）：设有2个图$G_1=(V_1, E_1)$和$G_2=(V_2, E_2)$，若$V_2$是$V_1$的子集且$E_2$是$E_1$的子集，那么称$G_2$为$G_1$的子图。若满足$V_1=V_2$则称$G_2$为$G_1$的生成子图。注意并非$V$和$E$的任意子集都能构成$G$的子图，因为有些子集的组合可能不是图。

边数很少的图称之为稀疏图（sparse graph），反之则为稠密图（dense graph）。

### 0x02 基本概念

#### 0x00 度

图中一个顶点的度（degree或valency）即为以该顶点为一个端点的边的数目。

对于无向图而言，顶点v的度是指依附于该顶点的边的条数，记为TD(v)。

> 国外教材上一般把顶点的度记为$\deg(v)$，并且将入度记为$\deg^-(v)$，将出度记为$\deg^+(v)$，此处指明的TD即为Total Degree的缩写。

**无向图**的全部顶点的度之和等于边数的两倍，即有如下等式成立：
$$
\sum_{i=1}^n\deg(v_i)=2\times e
$$

> 其中n为顶点的个数，e为边的条数。因为每条边都和两个顶点相互关联。

**有向图**中顶点的度又分为入度（indegree）和出度（outdegree），并且一张图总的度数等于其入度及出度之和。

有向图中入度之和等于出度之和等于边的条数，因为每个有向边都有一个起点和一个终点，即有如下等式成立：
$$
\sum_{i=1}^n\deg^-(v_i)=\sum_{i=1}^n\deg^+(v_i)=e
$$

#### 0x01 路径及回路

从顶点v到顶点w的路径是指从v到w的一个**顶点序列**，路径上边的数目称之为路径长度。**一条路径中，第一个顶点与最后一个顶点相同的路径称之为回路或者环**，如果一个图有N个顶点，并且有大于N-1条边，则此图中一定有环。

### 0x03 图的基本存储方式

#### 0x00 邻接矩阵法

邻接矩阵法（Adjacency matrix）就是用一个一维数组存储图中的顶点信息，用一个二维数组（邻接矩阵）存储图中边的信息（各顶点的邻接关系）。

结点数为$N$的图的邻接矩阵是$N \times N$的，将这个矩阵记为$A$，`A[i][j]=1`的条件是图中存在边$(v_i,w_j)$或$<v_i,w_j>$。否则`A[i][j]=0`。对于带权图而言，当边存在时，其邻接矩阵的取值为当前边的权值，不存在时一般取$0$或$\infty$。

使用邻接矩阵法存储图的空间复杂度为$O(N^2)$。我们可以通过使用STL中的map将这个二维数组尽可能地压缩一下，当然最坏情况下还是要占用$N^2$的空间的，例如将邻接矩阵定义为：

```c++
std::map<int, std::map<int, int>> arcs;
          ^             ^    ^
         顶点v        顶点w  权值或是否存在路径
```

这样如果我们试图判断边$(v,w)$是否存在时，可以使用如下代码：

```c++
arcs.find(v) != arcs.end() && arcs[v].find(w) != arcs[v].end()
```

> 为什么使用上述语句而不直接使用如下的形式判断：
>
> ```c++
> arcs[v][w] ? "Yes" : "No"
> ```
>
> 上面的这种形式对于map来说是很不安全的，原因很简单，当这个map里面并没有这一项的时候，你使用上面的这种形式判断是否存在此项，map也会给你创建出一个来，也就是说**即便你没有对map进行插入操作，你使用[]运算符判断是否存在，map也会给你把这一项创建出来**。
>
> 我们可以在STL的源代码里看到如下的代码：
>
> ```c++
> template<class _Keyty,
> 		class... _Mappedty>
> 		_Pairib _Try_emplace(_Keyty&& _Keyval,
> 			_Mappedty&&... _Mapval)
> 		{	// fail if _Keyval present, else emplace
> 		iterator _Where = _Mybase::lower_bound(_Keyval);
> 		if (_Where == _Mybase::end()
> 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),
> 				_Keyval, _Mybase::_Key(_Where._Ptr)))
> 			return (_Pairib(
> 				_Mybase::emplace_hint(_Where,
> 					piecewise_construct,
> 					_STD forward_as_tuple(
> 						_STD forward<_Keyty>(_Keyval)),
> 					_STD forward_as_tuple(
> 						_STD forward<_Mappedty>(_Mapval)...)),
> 				true));
> 		else
> 			return (_Pairib(_Where, false));
> 		}
> // 对其中的emplace_hint的代码如下：
> 	template<class... _Valty>
> 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
> 		{	// insert value_type(_Val...) at _Where
> 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
> 		return (_Insert_hint(_Where, _Newnode->_Myval, _Newnode));
> 		}
> ```
>
> 当判断条件`_Where == _Mybase::end()`成立时，也就是当前map中并没有这一项时，他就会执行调用函数`emplace_hint`在`_Mybase::end()`处（使用默认构造函数）新建这一项。而且此时函数会返回新创建的这一项，多数情况下，我们仅仅是为了判断此项是否存在，而不希望其不存在时还要把这一项创建出来，所以判断key是否存在于map中，我们可以使用其find函数，检查其返回值是否等于`map.end()`。

使用邻接矩阵法存储图时，有如下特点：

* 无向图的邻接矩阵一定是对称矩阵，并且唯一。
* 无向图的邻接矩阵第`i`行的非零元素的个数恰好是图第`i`个结点的度。
* 有向图的邻接矩阵第`i`行的非零元素的个数恰好是图第`i`个结点的出度，第`i`列的非零元素的个数恰好是图第`i`个结点的入度。
* **邻接矩阵法适合存储稠密图。**
* 使用邻接矩阵法可以快速确定任意两个结点之间是否有边相连，因为数组随机访问的效率要远远高于链表（对应为邻接表）。

#### 0x01 邻接表法

邻接表（Adjacency list）主要是为了解决使用临界矩阵存储稀疏图时空间大量浪费的问题。邻接表就是对图中的每一个顶点都建立一个单链表，来存储当前结点所有的边，对于有向图而言则存储所有的出边（就是从当前结点出发到对方结点的点）。

先给出一个用单链表实现的：

```c++
// 表结点（表示图的边）
struct Arcnode {
   int adjvex;                  // 这条边所指向顶点位置
   struct Arcnode *nextarc;     // 指针指向下一条边
};
// 表头结点（表示图的顶点）
struct VNode {
   int data;                    // 顶点数据，这里用字符表示
   struct Arcnode * firstarc;   // 指针指向第一条边 
};
// 图
struct MGraph {
   struct VNode vexs[100];
   int vexsnum, arcnum;          // 顶点数，边数
} *g;
```

如果是使用C++的话，还可以用这个实现：

```c++
std::vector<std::vector<int>> graph;
```

因为`vector`本身就是一个可动态扩容的数组，其初始情况下默认分配一段较小的存储空间，随着存储规模的增长，其会动态扩容。这种方法严格意义上来说其实不能算为邻接表。

使用邻接表存储有如下特点：

* 如果G为无向图的话，那么其所占用的存储空间为$|V|+2|E|$，因为同样的一条边会在邻接表中出现两次。
* 如果G为有向图的话，那么其所占用的存储空间为$|V|+|E|$。
* **邻接表适合存储稀疏图**。因为这将极大地节省存储空间。
* 在邻接表中，给定一顶点，可很快地找到其临边，给定一条边，也可以很快判定这条边在图中是否存在，但是在邻接矩阵中，因为使用单链表去实现，所以相同的操作往往需要扫描一行，所以时间复杂度为$O(N)$。
* **图的邻接表并不唯一**，这往往取决于建立邻接表的算法以及输入序列。

#### 0x02 十字链表

十字链表（Orthogonal list）是**有向图**的一种链式存储方式。语言不是很好描述，看图：

![](https://bucket.shaoqunliu.cn/image/0174.png)

其中：

入弧表示箭头指向当前结点的弧长，出弧表示从当前结点出发到别的结点的弧。

弧头表示箭头所指向的顶点，弧尾表示发出箭头的顶点。

```c++
struct ArcNode      // 弧
{
    int head, tail; // 该弧的头尾顶点
    OLNode *right;  // 用来记录同弧尾的顶点
    OLNode *down;   // 用来记录同弧头的顶点
};

struct VNode           // 顶点表
{
    ArcNode *firstin;  // 入弧
    ArcNode *firstout; // 出弧
    int value;         // 顶点信息
};
```

顶点之间可使用顺序存储。

图的十字链表不唯一，但是一个十字链表可准确地确定一个图。

#### 0x03 邻接多重表

邻接多重表（Adjacency Multi List）是**无向图**的另一种链式存储结构。

在邻接表中，容易求得顶点和边的信息，但是如果需要判断两个顶点之间是否存在边，或者进行边的删除操作，那么需要在两个链表之间进行遍历，效率较低。

如图，一个用邻接表表示的图中，如果想要删除$<v_0,v_2>$这条边，则需要对邻接表中的两个结点进行删除。

![](https://bucket.shaoqunliu.cn/image/0175.jpg)

在邻接多重表中每一条边用一个结点表示，先看图：

![](https://bucket.shaoqunliu.cn/image/0176.png)

在一个邻接多重表中，`ivex`和`jvex`代表了当前边所连接的两个顶点，`ilink`指向下一条依附于`ivex`的边，`jlink`指向下一条依附于`jvex`的边。

在有些实现中，存储边信息的结点往往还多2个域，即`mark`标识域，即标记当前边有没有被搜索过，以及`info`域，指向和边相关的各种信息。

相关实现如下：

```c++
struct ArcNode {
    bool mark;      // 访问标记
    int ivex;       // 边顶点一
    int jvex;       // 边顶点二
    ArcNode *ilink; // 指向依附于顶点一的下一条边,类似于起点相同的一条弧
    ArcNode *jlink; // 指向依附于顶点二的下一条边,类似与终点想同的一条弧
    int weight;	    // 边的权值
};
  
struct VNode {
    int data;           // 数据
    ArcNode *firstarc;	// 指向第一条依附于该顶点的边
};
```

