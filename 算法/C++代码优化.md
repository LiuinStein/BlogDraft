### 0x00 C++代码优化

在这里讲述一些代码优化的奇技淫巧：

#### 0x00 位运算

位运算往往比普通的加减乘除运算快很多，例如：

$\frac{a}{2^b}$可以写为`a >> b`，$a\cdot2^b$可以写为`a << b`

$a\,mod\,2^b$ 可以写为`a & 2^b -1`，例如10与4取余即为`10 & 3`

计算int类型a与b的平均值，如果使用表达式$\frac{a+b}{2}$可能会出现a+b溢出的情况，但a+b的平均值只能小于等于max(a, b)，也就说绝不会溢出，此处可以使用位运算做一个不会溢出的平均值计算：

```
(a&b)+((a^b)>>1)
```

不适用临时变量互换两个整数：

```
x ^= y;
y ^= x;
x ^= y;
```

#### 0x01 减少运算强度

当计算$a^b$时，如果b比较小的话可以直接写成`a*a*a`的形式避免使用`pow`函数

使用自增自减运算符来代替诸如`i = i + 1`这样的运算，`i = i + 1`往往生成如下汇编代码：

```assembly
move A,i ; 把x从存储器取出存入累加器A 
add A,1  ; 累加器A加1 
store i  ; 把新值存回x 
```

如果使用`++i`的话，对于大多数CPU来说就只有一行汇编指令了：

```assembly
incr i ; i加1
```

同样，尽量使用`++i`而不是`i++`，此处对于迭代器来说同样适用，因为`i++`往往伴随着多余的存指令和取指令，此处可以对比STL中迭代器重载的前置自增和后置自增运算符代码：

```c++
_Vector_iterator& operator++()
{	// preincrement, 前置自增(++i)
    ++*(_Mybase *)this;
    return (*this);
}

_Vector_iterator operator++(int)
{	// postincrement, 后置自增(i++), 需要建立临时变量, 多出来的存取操作
    _Vector_iterator _Tmp = *this;
    ++*this;
    return (_Tmp);
}
```

使用复合表达式，例如将`a = a + b`改为`a += b`，这个也是老生常谈了



