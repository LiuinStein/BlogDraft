### 0x00 查找

主要有如下查找算法（Searching Algorithms)：

* 顺序查找（Linear Search）
* 二分查找（又称折半查找Binary Search）

以及几个对查找优化的数据类型：

* 哈希表（又称散列表Hash Table）
* B树

介绍一个基本概念叫做平均查找长度（ASL）：

ASL的计算公式如下：
$$
ASL=\sum_{i=1}^n P_i\times C_i
$$

> 上式中
>
> * n为查找长度
> * $P_i$为第$i$个元素为目标的概率
> * $C_i$为找到第$i$个元素所需要进行的比较次数

### 0x01 顺序查找和二分查找

#### 0x00 顺序查找

顺序查找不做详述，就是最简单的查找算法，从第一个开始往后依次查找，直到找到目标或者到达结尾。顺序表一般针对**无序的序列**。

在此，不给出代码了，仅分析其平均查找长度，对于顺序查找而言在查找成功的情况下，ASL计算为：
$$
ASL=\sum_{i=1}^n \frac{i}{n} = \frac{n+1}{2}
$$
其中，认为每个元素的查找概率均相同均为$\frac{1}{n}$，当定位目标元素为第$i$个元素时，需进行$i$次比较。

如果查找不成功的话，表中所有的元素都要被比较一次，而且最后还多了一次输入是否到头的比较过程，比较次数即为$n+1$，平均查找长度即为$ASL=n+1$。

顺序查找对表没有任何的要求，可以是顺序表也可是链表，可以有序也可以无序。但是当N较大时，平均查找较长，效率较低。同时对线性的链表只能进行顺序查找。

还要单独说一下有序表的顺序查找，如果在查找之前就知道输入序列有序的话，例如如下输入序列：

```
1 2 4 5 6 7 8 9
```

当我要查找元素3时，当查找到第一个比3大的元素时还没有找到3，算法就可以终止了，在此处，当比较到4时，就没必要再继续下去了。这样可以进一步地优化一下查找失败时的平均查找长度：
$$
ASL_{查找失败时}=\frac{1+2+3+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$
反正也查不到，那平均到每一次到达失败结点的概率即为$\frac{1}{n+1}$，此处n+1的原因是有n+1个查找失败的顶点，因为我把整个表全部扫描了一遍，我最后还多了一次判断输入是否到头的比较过程。分子最后多了个+n的原因是，当查找进行到输入数据末尾时，由于每一次查找都多了一次比较当前元素是否小于被查找元素的过程，有n个元素，自然也多了n次比较小于的过程。

#### 0x01 二分查找

二分查找又称折半查找，一般用于有序的顺序表。

先从一道LeetCode题目说起，[704. Binary Search](https://leetcode.com/problems/binary-search/description/)，这是一道简单题，目的很单纯，就是给你一个顺序表，然后给你一个待查找的元素，让你使用二分查找的方法来查找元素在顺序表中的位置，代码如下：

```c++
class Solution {
public:
    int search(std::vector<int>& nums, int target) {
        int lo = 0, hi = nums.size(), mid;
        while (lo < hi)
        {
            mid = (lo + hi) >> 1;
            if (nums[mid] == target)
            {
                return mid;
            }
            else if(nums[mid] > target)
            {
                hi = mid;
            }
            else
            {
                lo = mid + 1;
            }
        }
        return -1;
    }
};
```

二分查找的过程可以用一棵二叉树来描述，这棵二叉树也被称为判定树，

对于一个待查找的输入数列：

```
1 2 3 4 5 6 7 8 9 10 11 12
```

我们可以画出其二分查找时的判定树，如下图：

![](https://bucket.shaoqunliu.cn/image/0186.png)

下面来分析一下二分查找的平均查找长度：

由上图可以看出，使用二分查找查找到给定值的时间复杂度不会超过其判定树的高度，所以有：
$$
ASL=\sum_{i=1}^h{\frac{1}{n}\times (i\times2^{i-1})} \\
ASL=\frac{1}{n} \times (1\times1+2\times2+...+h\times2^{h-1})\\
ASL=\frac{n+1}{n}\log_2{(n+1)}-1 \\
\Rightarrow ASL\approx \log_2{(n+1)}-1
$$

在上式中，h为判定树的高度，当有N个结点时，判定树的高度为：

$$
h=\lceil \log_2{(N+1)} \rceil由此可知，
$$

由此可知，二分查找的时间复杂度为$O(\log_2{N})$。

二分查找有一个特点就是需要方便地定位到数列中间的那个位置，所以适合用二分查找的存储结构要具有随机访问的特性，例如数组。因此其并不适用于链表等链式存储结构。

#### 0x02 分块查找

分块查找又称索引顺序查找，可以看为是二分查找和顺序查找的一个整合版本，其基本思想是：

* 将查找表分为若干块，块内的元素可以是无序的，但是块与块之间是有序的，例如第一个块中的最大关键字小于第二个块中的最小关键字，以此类推。
* 有一个索引表，索引表包含了每个块含有的最大关键字，以及第一个起始元素的位置，索引表按关键字有序排列。

分块查找的查找过程分两步，第一步在索引表中确定待查记录所在的块，可以使用顺序查找或折半查找，然后第二步在块内顺序查找。

将索引查找的平均查找长度记为$L_I$，块内查找的平均查找长度记为$L_S$，则ASL有如下计算：
$$
ASL=L_I+L_S\\
$$
设将长度为n的表平均分为了b块，每块有s条记录，若对索引表使用二分查找时，平均查找长度为：
$$
ASL=\lceil \log_2{(b+1)} \rceil+\frac{s+1}{2}
$$
若对索引表也使用顺序查找，则平均查找长度为：
$$
ASL=\frac{b+1}{2}+\frac{s+1}{2}\\
代入b=\frac{n}{s}有:ASL=\frac{n+s}{2s}+\frac{s+1}{2}\\
\Rightarrow ASL=\frac{s^2+2s+n}{2s}
$$
