### 0x00 链表

在[Wikipedia](https://en.wikipedia.org/wiki/Linked_list)上对链表的定义是一个线性的存储数据的结合。

链表中每一个用于存储数据的单元叫做element或者node，每一个结点中都包含一个指向下一个结点的指针一般被称为next link或者next pointer，剩余的元素一般为数据元素，一般被称为data, information, value, cargo或者payload。链表的第一个元素被称为链表的head。

在某些链表的实现方法中，一般会在链表真正记录数据的结点之前或尾部加入一个多余的结点，通常用来简化或者加速某些链表的算法（list-handling algorithms）或者用于确保链表可以被安全地取消引用（safely dereferenced）以及确保链表始终具有第一个或者最后一个结点，这个结点往往被称为哨兵结点（Sentinel nodes）。

链表一般分为如下几种：

* 单向链表（Singly linked list）
  单向链表中的结点往往含有数据元素以及一个指向下一个链表结点的指针

* 双向链表（Doubly linked list）
  双向链表中的结点往往含有数据元素以及一个指向下一个链表结点的指针（next或forwards）以及一个指向上一个链表结点的指针（previous或backwards），使其可以自由的前后移动。
  很多现代操作系统使用双向链表来维护活跃进程、线程以及其他动态对象的引用。很多Rootkit软件就是通过将自己与这些链表解除链接以躲过检测。

  > Rootkit一般是指那些用来隐藏其他程序进程的软件。一般都是恶意软件，说白了比如隐藏自己让你无法在任务管理器中找到相关的进程信息。

* 多向链表（Multiply linked list）
  在一个多向链表中，每一个结点都可能包含2个或多个指针字段用于指向某一特定的数据集，例如想象一个用于存放个人信息的链表，其中有1个指针用于指向链表的下一个结点，还有一个指针指向一个`const char *`类型的name字段。这个链表即为多向链表。

* 循环链表（Circular linked list）
  循环链表就是链表的最后一个结点的next指针知道当前链表的第一个结点，形成一个闭合的环的结构。通常情况下链表的next指针一般指向NULL值，用来指示当前结点已经没有下一个可用的结点了。

主要涉及算法：

* 链表的插入及删除
* 正向逆向遍历单向链表
* 按值查找与按位查找

### 0x01 单向链表相关算法及其实现

#### 0x00 插入及删除



单链表的删除，从一道LeetCode题目看起[Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/)，这道题目要求你删除单链表中与给定数据匹配的数据，代码如下：

```c++
class Solution {
public:
    ListNode * removeElements(ListNode* head, int val) {
        if (!head)
        {
            return nullptr;
        }
        ListNode *prev{ head }, *current{ head->next };
        while (current)
        {
            if (current->val == val)
            {
                prev->next = current->next;
                delete current;
                current = prev->next;
            }
            else
            {
                prev = current;
                current = current->next;
            }
        }
        if (head->val == val)
        {
            ListNode *dummy{ head->next };
            delete head;
            return dummy;
        }
        return head;
    }
};
```

上述代码的时间复杂度为$O(N)$

#### 0x01 遍历



#### 0x02 按值查找与按位查找



#### 0x03 逆置单链表

逆置单链表的问题，无需改变的链表的结构，$O(N)$的时间复杂度即可完成，对于LeetCode题目[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)，我一开始给出了如下代码，$O(N)$的时间复杂度再加上$O(N)$的空间复杂度：

```c++
class Solution {
public:
    ListNode * reverseList(ListNode* head) {
        std::vector<int> nums;
        for (ListNode *p = head; p != NULL; p = p->next)
        {
            nums.emplace_back(p->val);
        }
        int count = nums.size();
        for (ListNode *p = head; p != NULL; p = p->next)
        {
            p->val = nums[--count];
        }
        return head;
    }
};
```

但是看了别人的提交记录之后，发现有人用一趟while循环外加$O(1)$的空间复杂度就把问题解决了，它的思路就是改变链表的物理结构，让链表从结构上整体翻转，而不是像我那样只改变里面的数字不改变物理结构，学会了它的思路后，自己动手写了一个，耗时4ms击败100%的人，$O(N)$的时间复杂度以及$O(1)$的额外空间占用代码如下：

```c++
class Solution {
public:
    ListNode * reverseList(ListNode* head) {
        if (!head || !head->next)
        {
            return head;
        }
        ListNode *prev{ nullptr },
            *current{ head },
            *next{ current->next };
        while (next)
        {
            current->next = prev;
            prev = current;
            current = next;
            next = current->next;
        }
        current->next = prev;
        return current;
    }
};
```

题目逆置单链表加强版[Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/description/)，题目提示Do it in one-pass.也就是使用一趟循环实现，代码如下，$O(N)$的时间复杂度以及$O(1)$的空间复杂度：

```c++
class Solution {
public:
    ListNode * reverseBetween(ListNode* head, int m, int n) {
        ListNode *prev{}, *current{}, *next{},
            *dummy{ head }, *left{};
        for (int i = 1; i <= n; ++i)
        {
            if (i > m)
            {
                current->next = prev;
                prev = current;
                current = next;
                next = current->next;
            }
            else if (i == m)
            {
                current = dummy;
                next = current->next;
            }
            else
            {
                left = dummy;
                dummy = dummy->next;
            }
        }
        current->next = prev;
        dummy->next = next;
        if (left)
        {
            left->next = current;
        }
        if (m == 1)
        {
            return current;
        }
        return head;
    }
};
```

因为**每次循环都要进行if-else if-else判断结构**，导致代码的整体效率偏低，我又撰写了另一个版本，

```c++
class Solution {
public:
    ListNode * reverseBetween(ListNode* head, int m, int n) {
        int size{ n - m + 1 };
        int *nums = new int[size];
        ListNode *dummy{ head }, *begin{};
        for (int i = 1; i < m; ++i, dummy = dummy->next);
        begin = dummy;
        for (int i = 0; i < size; nums[i] = dummy->val, dummy = dummy->next, ++i);
        for (int i = n - m; i >= 0; begin->val = nums[i], begin = begin->next, --i);
        return head;
    }
};
```

设需要逆置的区间为$[M,N]$则，算法的时间复杂度为$O(2N-M+2)$



### 0x02 双向链表相关算法及其实现

#### 0x00 插入及删除



#### 0x01 遍历



#### 0x02 按值查找与按位查找



### 0x03 循环链表相关算法及其实现

#### 0x00 插入及删除



#### 0x01 遍历



#### 0x02 按值查找与按位查找

