### 0x00 链表

在[Wikipedia](https://en.wikipedia.org/wiki/Linked_list)上对链表的定义是一个线性的存储数据的结合。

链表中每一个用于存储数据的单元叫做element或者node，每一个结点中都包含一个指向下一个结点的指针一般被称为next link或者next pointer，剩余的元素一般为数据元素，一般被称为data, information, value, cargo或者payload。链表的第一个元素被称为链表的head。

在某些链表的实现方法中，一般会在链表真正记录数据的结点之前或尾部加入一个多余的结点，通常用来简化或者加速某些链表的算法（list-handling algorithms）或者用于确保链表可以被安全地取消引用（safely dereferenced）以及确保链表始终具有第一个或者最后一个结点，这个结点往往被称为哨兵结点（Sentinel nodes）。

链表一般分为如下几种：

* 单向链表（Singly linked list）
  单向链表中的结点往往含有数据元素以及一个指向下一个链表结点的指针

* 双向链表（Doubly linked list）
  双向链表中的结点往往含有数据元素以及一个指向下一个链表结点的指针（next或forwards）以及一个指向上一个链表结点的指针（previous或backwards），使其可以自由的前后移动。
  很多现代操作系统使用双向链表来维护活跃进程、线程以及其他动态对象的引用。很多Rootkit软件就是通过将自己与这些链表解除链接以躲过检测。

  > Rootkit一般是指那些用来隐藏其他程序进程的软件。一般都是恶意软件，说白了比如隐藏自己让你无法在任务管理器中找到相关的进程信息。

* 多向链表（Multiply linked list）
  在一个多向链表中，每一个结点都可能包含2个或多个指针字段用于指向某一特定的数据集，例如想象一个用于存放个人信息的链表，其中有1个指针用于指向链表的下一个结点，还有一个指针指向一个`const char *`类型的name字段。这个链表即为多向链表。

* 循环链表（Circular linked list）
  循环链表就是链表的最后一个结点的next指针知道当前链表的第一个结点，形成一个闭合的环的结构。通常情况下链表的next指针一般指向NULL值，用来指示当前结点已经没有下一个可用的结点了。

主要涉及算法：

* 链表的插入及删除
* 正向逆向遍历单向链表
* 按值查找与按位查找

### 0x01 单向链表相关算法及其实现

#### 0x00 插入、删除、查找

有关单项链表的基本操作，插入、删除、获取其中某个位置的元素，可以参考LeetCode题目[707. Design Linked List](https://leetcode.com/problems/design-linked-list/description/)，此题要求你设计一个单项链表，以完成以下操作：

* `get(index)`: 获取某一特定位置的元素
* `addAtHead(val)`: 在链表头部添加元素
* `addAtTail(val)`: 在链表尾部添加元素
* `addAtIndex(index, val)`: 在下标为index的元素之前添加一个元素
* `deleteAtIndex(index)`: 删除下标为index的元素

```cpp
// 提交前注释掉此链表结构，否则LeetCode会报ListNode重定义错误
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class MyLinkedList {

    ListNode *head;
    ListNode *tail;
    int size;
public:
    /** Initialize your data structure here. */
    MyLinkedList() {
        head = new ListNode(0);
        tail = new ListNode(0);
        head->next = tail;
        tail->next = nullptr;
        size = 0;
    }

    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    int get(int index) {
        if (index + 1 > size || index < 0)
        {
            return -1;
        }
        ListNode *dummy{ head->next };
        while (index--)
        {
            dummy = dummy->next;
        }
        return dummy->val;
    }

    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    void addAtHead(int val) {
        head->val = val;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        head = dummy;
        ++size;
    }

    /** Append a node of value val to the last element of the linked list. */
    void addAtTail(int val) {
        tail->val = val;
        ListNode *dummy = new ListNode(0);
        tail->next = dummy;
        tail = dummy;
        ++size;
    }

    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    void addAtIndex(int index, int val) {
        if (index == size)
        {
            addAtTail(val);
            return;
        }
        if (index > size || index < 0)
        {
            return;
        }
        ListNode *dummy{ head };
        while (index--)
        {
            dummy = dummy->next;
        }
        ListNode *element = new ListNode(val);
        element->next = dummy->next;
        dummy->next = element;
        ++size;
    }

    /** Delete the index-th node in the linked list, if the index is valid. */
    void deleteAtIndex(int index) {
        if (index + 1 > size || index < 0)
        {
            return;
        }
        ListNode *dummy{ head };
        while (index--)
        {
            dummy = dummy->next;
        }
        ListNode *deleted = dummy->next;
        dummy->next = deleted->next;
        deleted->next = nullptr;
        delete deleted;
        --size;
    }
};
```

此题如果在设计链表时在头部和尾部均添加一个多余的哨兵结点，会使整个算法的效率提升，以及简化代码量，尤其是在向尾部添加一个元素时，如果不使用哨兵结点，向尾部添加元素时，需要提前遍历至尾部，此过程的时间复杂度为$O(N)$，如果使用哨兵结点就可以将时间复杂度缩短到$O(1)$。此代码超越99.84%的人，前面唯一一个比它快的代码是使用的vector来作的弊。

单链表的删除，从一道LeetCode题目看起[Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/)，这道题目要求你删除单链表中与给定数据匹配的数据，代码如下：

```c++
class Solution {
public:
    ListNode * removeElements(ListNode* head, int val) {
        if (!head)
        {
            return nullptr;
        }
        ListNode *prev{ head }, *current{ head->next };
        while (current)
        {
            if (current->val == val)
            {
                prev->next = current->next;
                delete current;
                current = prev->next;
            }
            else
            {
                prev = current;
                current = current->next;
            }
        }
        if (head->val == val)
        {
            ListNode *dummy{ head->next };
            delete head;
            return dummy;
        }
        return head;
    }
};
```

上述代码的时间复杂度为$O(N)$

#### 0x01 逆置单链表

逆置单链表的问题，无需改变的链表的结构，$O(N)$的时间复杂度即可完成，对于LeetCode题目[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)，我一开始给出了如下代码，$O(N)$的时间复杂度再加上$O(N)$的空间复杂度：

```c++
class Solution {
public:
    ListNode * reverseList(ListNode* head) {
        std::vector<int> nums;
        for (ListNode *p = head; p != NULL; p = p->next)
        {
            nums.emplace_back(p->val);
        }
        int count = nums.size();
        for (ListNode *p = head; p != NULL; p = p->next)
        {
            p->val = nums[--count];
        }
        return head;
    }
};
```

但是看了别人的提交记录之后，发现有人用一趟while循环外加$O(1)$的空间复杂度就把问题解决了，它的思路就是改变链表的物理结构，让链表从结构上整体翻转，而不是像我那样只改变里面的数字不改变物理结构，学会了它的思路后，自己动手写了一个，耗时4ms击败100%的人，$O(N)$的时间复杂度以及$O(1)$的额外空间占用代码如下：

```c++
class Solution {
public:
    ListNode * reverseList(ListNode* head) {
        if (!head || !head->next)
        {
            return head;
        }
        ListNode *prev{ nullptr },
            *current{ head },
            *next{ current->next };
        while (next)
        {
            current->next = prev;
            prev = current;
            current = next;
            next = current->next;
        }
        current->next = prev;
        return current;
    }
};
```

题目逆置单链表加强版[Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/description/)，题目提示Do it in one-pass.也就是使用一趟循环实现，代码如下，$O(N)$的时间复杂度以及$O(1)$的空间复杂度：

```c++
class Solution {
public:
    ListNode * reverseBetween(ListNode* head, int m, int n) {
        ListNode *prev{}, *current{}, *next{},
            *dummy{ head }, *left{};
        for (int i = 1; i <= n; ++i)
        {
            if (i > m)
            {
                current->next = prev;
                prev = current;
                current = next;
                next = current->next;
            }
            else if (i == m)
            {
                current = dummy;
                next = current->next;
            }
            else
            {
                left = dummy;
                dummy = dummy->next;
            }
        }
        current->next = prev;
        dummy->next = next;
        if (left)
        {
            left->next = current;
        }
        if (m == 1)
        {
            return current;
        }
        return head;
    }
};
```

因为**每次循环都要进行if-else if-else判断结构**，导致代码的整体效率偏低，我又撰写了另一个版本，

```c++
class Solution {
public:
    ListNode * reverseBetween(ListNode* head, int m, int n) {
        int size{ n - m + 1 };
        int *nums = new int[size];
        ListNode *dummy{ head }, *begin{};
        for (int i = 1; i < m; ++i, dummy = dummy->next);
        begin = dummy;
        for (int i = 0; i < size; nums[i] = dummy->val, dummy = dummy->next, ++i);
        for (int i = n - m; i >= 0; begin->val = nums[i], begin = begin->next, --i);
        return head;
    }
};
```

设需要逆置的区间为$[M,N]$则，算法的时间复杂度为$O(2N-M+2)$

#### 0x02 奇靠前偶靠后

这个是来源于一道LeetCode题目[328. Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/description/)，此题要求你将下标为偶数的元素全部移动到链表的最后，而且要在源链表的物理结构上实现（in place），我的代码如下：

```c++
class Solution {
public:
    ListNode * oddEvenList(ListNode* head) {
        if (!head || !head->next)
        {
            return head;
        }
        ListNode *dummyHead{ head }, *even{ new ListNode(0) };
        ListNode *dummyHeadPrev{}, *dummyEven{ even };
        while (dummyHead && dummyHead->next)
        {
            dummyEven->next = dummyHead->next;
            dummyEven = dummyEven->next;
            dummyHead->next = dummyHead->next->next;
            dummyHeadPrev = dummyHead;
            dummyHead = dummyHead->next;
        }
        dummyEven->next = nullptr;
        ListNode **tail{ dummyHead ? &dummyHead : &dummyHeadPrev };
        (*tail)->next = even->next;
        return head;
    }
};
```

运行时间8ms超过100%的人，时间复杂度为$O(\frac{N}{2})$，while循环两个两个跳着走就可以，空间复杂度为$O(1)$。

### 0x02 双向链表相关算法及其实现

#### 0x00 插入及删除



#### 0x01 遍历



#### 0x02 按值查找与按位查找



### 0x03 循环链表相关算法及其实现

#### 0x00 插入及删除



#### 0x01 遍历



#### 0x02 按值查找与按位查找

