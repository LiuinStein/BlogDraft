### 0x00 排序算法

在[Wikipedia](https://en.wikipedia.org/wiki/Sorting_algorithm)上一共列举了11种排序算法，分为4大类，如下

* Simple sorts 简单排序
  * Insertion sort 插入排序
  * Selection sort 选择排序
* Efficient sorts 高效排序
  * Merge sort 归并排序
  * Heapsort 堆排序
  * Quicksort 快速排序
* Bubble sort and variants 冒泡排序及其变体
  * Bubble sort 冒泡排序
  * Shell sort 希尔排序
  * Comb sort 梳排序
* Distribution sort 分配排序
  * Counting sort 计数排序
  * Bucket sort 桶排序
  * Radix sort 基数排序

### 0x01 术语

先来说说术语，有些术语确实理解起来比较晦涩

#### 0x00 比较型排序算法和非比较型排序算法

比较型排序算法（Comparison sorts）

比较型排序算法就是我们一般常用的那几个排序算法，通过**直接比较**数列中两个数的大小来完成排序。

> 摘自[维基百科](https://en.wikipedia.org/wiki/Comparison_sort)：
>
> A **comparison sort** is a type of [sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm) that only reads the list elements through a single abstract comparison operation (often a "less than or equal to" operator or a [three-way comparison](https://en.wikipedia.org/wiki/Three-way_comparison)) that determines which of two elements should occur first in the final sorted list.

非比较型排序算法（Non-comparison sorts）

**不通过直接比较**序列中两个数的大小来完成排序，所有能用非比较型排序算法的序列都能用比较型排序算法完成排序，但**反过来不成立**。

#### 0x01 稳定性(Stability)

假定在待排序的序列中，有两个值是相等的，排序过后，如果这两个相等的值在排序后序列的相对次序保持不变，那么就是稳定的，否则就是不稳定的，如下图：

![](https://bucket.shaoqunliu.cn/image/0151.png )

### 0x02 排序算法比较

仅给出比较型排序算法(Comparison sorts)

| 算法     | 最佳      | 平均    | 最坏    | 空间   | 稳定性 |
| -------- | --------- | ------- | ------- | ------ | ------ |
| 插入排序 | $n$       | $n^2$ | $n^2$  | $1$    | 稳定   |
| 选择排序 | $n^2$     | $n^2$   | $n^2$   | 1      | 不稳定 |
| 归并排序 | $nlog{n}$ | $nlog{n}$ | $nlog{n}$ | n      | 稳定   |
| 堆排序   | $n$     | $nlog{n}$ | $nlog{n}$ | 1      | 不稳定 |
| 快速排序 | $nlog{n}$  | $nlog{n}$ | $n^2$   | $log{n}$ | 都有 |
| 冒泡排序 | $n$ | $n^2$ | $n^2$ | 1 | 稳定 |
| 希尔排序 | $nlog{n}$ | - | $n^{\frac{4}{3}}$ | 1 | 不稳定 |
| 梳排序   | $nlog{n}$ | $n^2$ | $n^2$ | 1 | 不稳定 |

### 0x03 算法实现

#### 0x00 插入排序（Insertion Sort）

下面这个图来自维基百科，已经把插入排序算法的基本原理阐述地很清楚了：

![](https://bucket.shaoqunliu.cn/image/0152.gif)

顺便做一个LeetCode题，题目地址: [147. Insertion Sort List](https://leetcode.com/problems/insertion-sort-list/description/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
	ListNode * insertionSortList(ListNode *head) {
		if (head == NULL || head->next == NULL)
			return head;
		for (ListNode *p = head->next, *pLeft = head; p != NULL; pLeft = p, p = p->next)
		{
			if (p->val >= pLeft->val)
				continue;
			for (ListNode *q = head, *qLeft = NULL; q != p; qLeft = q, q = q->next)
			{
				if (p->val < q->val)
				{
					pLeft->next = p->next;
					if (qLeft != NULL)
					{
						ListNode* tmp = qLeft->next;
						qLeft->next = p;
						p->next = tmp;
					}
					else
					{
						p->next = head;
						head = p;
					}
					break;
				}
			}
		}
		return head;
	}
};
```

上面这个写法耗时52ms，当然不是最快的，最快的一个实现是这样的

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode *h = new ListNode(0);
        ListNode *cur = head;
        ListNode *prev = h;
        ListNode *next = NULL;
        while (cur)
        {
            next = cur->next;
            if (!prev || !prev->next || prev->next->val >= cur->val)
                prev = h;
            while (prev->next && prev->next->val < cur->val)
                prev = prev->next;
            cur->next = prev->next;
            prev->next = cur;
            cur = next;
        }
        return h->next;
    }
};
```

它这个算法将原来的链表拆分成2段，左边一段排序好了的，右边一段未排序的。

他这个算法**精妙的地方在于他这个prev这个指针的使用**

这个`prev`在左边经过排序的那一段链表内又将其分为两段，当从右边链表过来一个未排序的数的时候，通过与`prev`这个指针所指向的值进行大小比较，如果小，这个新值插入的位置就在右边开始(`h`指针)到`prev`指针所指向的位置，如果大，`prev`这个指针不动，从`prev`后面开始找插入点，实现了一个**类似于二分查找的方法**来进一步缩小了插入点的位置区间。

#### 0x01 选择排序（Selection sort）

维基百科上同样有一个图把这个算法描绘的比较清晰：

![](https://bucket.shaoqunliu.cn/image/0153.gif)



再来一个[LeetCode](https://leetcode.com/problems/sort-colors/description/)题目

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i)
		{
			int iMin = nums[i], pos = i;
			for (int j = i + 1; j < nums.size(); ++j)
			{
				if (iMin >= nums[j])
				{
					iMin = nums[j];
					pos = j;
				}
			}
			swap(nums[i], nums[pos]);
		}
    }
};
```

这个算法有着$O\,(n^2)$的时间复杂度，不过提交上去之后，居然，居然，居然：

击败了100%的人，不过我个人认为这个题目用**计数排序**会好很多，在下面计数排序的部分，我也打算用这个题来作为示例。

#### 0x02 归并排序（Merge sort）

维基百科上的图是真的全真的有意思：

![](https://bucket.shaoqunliu.cn/image/0160.gif)

归并排序首先依赖的是归并算法，归并算法用于归并两个排序过的序列，归并算法可以用[LeetCode上的题目](https://leetcode.com/problems/merge-sorted-array/description/)来练习一下：

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		std::vector<int> result;
		int i{}, j{};
		nums1.erase(nums1.begin() + m, nums1.end());
		while (i < m && j < n)
		{
			result.push_back(nums1[i] < nums2[j] ? nums1[i++] : nums2[j++]);
		}
		result.insert(result.end(), nums1.begin() + i, nums1.begin() + m);
		result.insert(result.end(), nums2.begin() + j, nums2.begin() + n);
		nums1 = result;
    }
};
```

归并数组没什么意思，也比较简单，来一个归并链表的，上[LeetCode题目](https://leetcode.com/problems/merge-k-sorted-lists/)，这个题目要求你归并N个有序链表，这些有序链表的头指针放在了一个vector中。我想到了两种解法：

解法1：

不断遍历这个vector中的头指针，然后找这些头指针所指向值的最小值，然后放入一个新的链表中作为返回结果，直到这个vector中的指针全部指向空，在此题中这种解法耗时198ms，代码如下：

```c++
class Solution {
	int getSmallestValue(std::vector<ListNode*>& lists)
	{
		int ret = lists[0]->val;
		int minRank = 0;
		for (int i = 0; i < lists.size(); ++i)
		{
			if (lists[i]->val < ret)
			{
				ret = lists[i]->val;
				minRank = i;
			}
		}
		lists[minRank] = lists[minRank]->next;
		if (lists[minRank] == NULL)
			lists.erase(lists.begin() + minRank);
		return ret;
	}
public:
	ListNode * mergeKLists(std::vector<ListNode*>& lists) {
		ListNode * result = new ListNode(0);
		ListNode * prev = result;
		ListNode * current = NULL;
		for (int i = 0; i < lists.size(); ++i)
		{
			if (lists[i] == NULL)
				lists.erase(lists.begin() + i--);
		}
		while (lists.size() > 0)
		{
			current = new ListNode(getSmallestValue(lists));
			prev->next = current;
			prev = current;
		}
		return result->next;
	}
};
```

解法2：

解法2就是两两归并，把N个有序链表两两一伙进行归并得到一些中间链表，然后再对这些中间链表进行两两归并直至归并成一个大的链表。一开始的时候我写下了如下的代码，Accept了，但是370ms的运行时间却不怎么令人满意：

```c++
class Solution {
	ListNode * merge(ListNode *lhs, ListNode *rhs)
	{
		ListNode *head = new ListNode(0);
		ListNode *cur = head;
		while (lhs != nullptr || rhs != nullptr)
		{
			if (lhs != nullptr && rhs != nullptr)
			{
				ListNode ** smallest = lhs->val < rhs->val ? &lhs : &rhs;
				cur->next = *smallest;
				*smallest = (*smallest)->next;
				cur = cur->next;
			}
			else
			{
				cur->next = lhs != nullptr ? lhs : rhs;
				break;
			}
		}
		return head->next;
	}
public:
	ListNode * mergeKLists(std::vector<ListNode*>& lists)
	{
		if (lists.size() == 0)
			return NULL;
		if (lists.size() == 1)
			return lists[0];
		ListNode *result = lists[0];
		for (int i = 1; i < lists.size(); ++i)
			result = merge(result, lists[i]);
		return result;
	}
};
```

看了某大牛的写法之后，我对上述代码进行了改良，仅改动了一下`mergeKLists`函数，就将运行时间减小到了24ms，超过100%的人，代码如下：

```c++
class Solution {
	ListNode * merge(ListNode *lhs, ListNode *rhs)
	{
		ListNode *head = new ListNode(0);
		ListNode *cur = head;
		while (lhs != nullptr || rhs != nullptr)
		{
			if (lhs != nullptr && rhs != nullptr)
			{
				ListNode ** smallest = lhs->val < rhs->val ? &lhs : &rhs;
				cur->next = *smallest;
				*smallest = (*smallest)->next;
				cur = cur->next;
			}
			else
			{
				cur->next = lhs != nullptr ? lhs : rhs;
				break;
			}
		}
		return head->next;
	}
public:
	ListNode * mergeKLists(std::vector<ListNode*>& lists)
	{
		int sz = lists.size();
		while (sz > 1) {
			int j = sz - 1;
			for (int i = 0; i < sz / 2; i++) {
				lists[i] = merge(lists[i], lists[j]);
				j--;
			}
			if (sz % 2 == 1)
				sz = sz / 2 + 1;
			else
				sz = sz / 2;
		}
		return sz > 0 ? lists[0] : NULL;
	}
};
```

我总结了一下原因，在一开始的解法中，我不断让结果链表与vector中的下一个链表进行归并，随着归并过程的不断进行，这个结果链表会越来越大，归并的过程也会越来越耗时。而第二种解法，vector中的链表两两归并，一开始的几次归并都是小链表与小链表之间的归并，只有最后几次是大链表之间的归并，减少了大链表参与归并的次数和规模，从而极大程度上缩短了算法的时间。

归并排序就是在归并算法的基础上，不断地讲一个未排序的序列进行拆分，最后两两一伙，对其中的一伙进行排序后，再不断归并，直至整个数列完全有序，上[LeetCode - Sort List ](https://leetcode.com/problems/sort-list/description/)题目，此题要求在$O(n\cdot log(n))$的时间内对单项链表进行排序，代码如下：

```c++
class Solution {
	ListNode * merge(ListNode *lhs, ListNode *rhs)
	{
		ListNode *head = new ListNode(0);
		ListNode *cur = head;
		while (lhs != nullptr || rhs != nullptr)
		{
			if (lhs != nullptr && rhs != nullptr)
			{
				ListNode ** smallest = lhs->val < rhs->val ? &lhs : &rhs;
				cur->next = *smallest;
				*smallest = (*smallest)->next;
				cur = cur->next;
			}
			else
			{
				cur->next = lhs != nullptr ? lhs : rhs;
				break;
			}
		}
		return head->next;
	}
public:
	ListNode * sortList(ListNode* head)
	{
		std::vector<ListNode*> sortedLists;
		ListNode *helper = head;
		for (ListNode *i = head; i != nullptr; )
		{
			if (i->next != nullptr && i->val > i->next->val)
			{
				sortedLists.push_back(helper);
				helper = i->next;
				i->next = nullptr;
				i = helper;
			}
			else
			{
				i = i->next;
			}
		}
		sortedLists.push_back(helper);
		int sz = sortedLists.size();
		while (sz > 1) {
			int j = sz - 1;
			for (int i = 0; i < sz / 2; i++) {
				sortedLists[i] = merge(sortedLists[i], sortedLists[j]);
				j--;
			}
			if (sz % 2 == 1)
				sz = sz / 2 + 1;
			else
				sz = sz / 2;
		}
		return sz > 0 ? sortedLists[0] : NULL;
	}
};
```

以上代码运行时间48ms超过97.44%的人，还不错，我的一个基本想法就是，对于一个无序序列而言，其中难免会出现些许的有序部分，例如无序序列`-1->5->3->4->0`，我们可以找到`-1->5`、`3->4`、`0`三个有序序列，首先通过一趟for循环将其中的有序部分拆分开来，然后将这些有序序列的头指针地址放入一个vector中，然后再依据上题归并N个有序链表的代码进行归并。

参考了LeetCode大神的解法，最快的解法耗时43ms，代码如下，不过这种方法有种作弊的感觉就是它先将链表里面的数据放在一个vector中，然后用vector的sort函数进行排序，然后再将排过序的vector中的值重新写回单向链表。

```c++
// LeetCode 最快43ms解法
class Solution {
public:
   ListNode* sortList(ListNode* head)
	{
		vector<int> vec;
		ListNode *ln = head;
		for (; ln != NULL; ln = ln->next)
		{
			vec.push_back(ln->val);
		}
		sort(vec.begin(), vec.end());
		ln = head;
		for (auto i : vec)
		{
			ln->val = i;
			ln = ln->next;
		}
		return head;
	}
};
```

第二快的方法耗时45ms，使用的是快速排序算法，这点等到下一节快速排序时再讲，第三快的方法使用归并排序耗时46ms：

```c++
class Solution {
    ListNode* merge(ListNode *l1, ListNode *l2) {
        ListNode dummy(INT_MIN);
        ListNode *node = &dummy;
        while(l1 && l2)
        {
            if(l1->val <= l2->val)
            {
                node->next = l1;
                l1 = l1->next;
            }
            else
            {
                node->next = l2;
                l2 = l2->next;
            }
            node = node->next;
        }
        node->next = l1 ? l1 : l2;
        return dummy.next;
    }
public:
    ListNode* sortList(ListNode* head) {
        if(head == NULL || head->next == NULL)
            return head;
        ListNode *slow = head;
        ListNode *fast = head->next;
        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        fast = slow->next;
        slow->next = NULL;
        return merge(sortList(head),sortList(fast));
    }
};
```



#### 计数排序（Counting sort）

如果需要排序的东西是一个**有限的小的可提前预知的**集合的话，那就可以使用计数排序。例如，我现在有一个由枚举类型组成的序列，这个枚举类型是由10个整数值组成的，那我们就可以通过计数这10个值在待排序的序列中一共有多少个，然后将其按个数重新写回序列，即为实现计数排序。

例如，这个[LeetCode](https://leetcode.com/problems/sort-colors/description/)题目就可以使用计数排序的方法实现，代码如下：

```c++
class Solution {
public:
	void sortColors(vector<int>& nums) {
		int helper[3]{};
		for (int i = 0; i < nums.size(); ++helper[nums[i]], ++i);
		for (int i = 0; i < nums.size(); ++i)
		{
			if (helper[0]-- > 0)
				nums[i] = 0;
			else if (helper[1]-- > 0)
				nums[i] = 1;
			else
				nums[i] = 2;
		}
	}
};
```

上面的这个实现是我写的，使用了两个for循环，在题设中有这样一句话：

> Could you come up with a one-pass algorithm using only constant space?

意思是你能用一趟for循环实现吗？想了想，实现代码如下：

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int zero_index = 0;
	    int two_index = nums.size() - 1;
		for (int i = 0; i <= two_index; i++) {
			if (nums[i] == 0)
				swap(nums[i], nums[zero_index++]);
			else if (nums[i] == 2)
				swap(nums[i--], nums[two_index--]);
        }
    }
};
```

这段代码需要注意的一个地方就是当当前的数字为2的时候，与后面的数字交换后需要将`i-1`使其重新判断当前`i`值所在的元素，反例如下，当输入数据为`[1,2,0]`时，且循环走到`i=1`，第一遍交换后得`[1,0,2]`，如果不将`i=1`重新置换一次，这个循环就走到头了，然后就出错啦！！！在这个地方花了一点时间，有点日狗。



