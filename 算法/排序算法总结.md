### 0x00 排序算法

在[Wikipedia](https://en.wikipedia.org/wiki/Sorting_algorithm)上一共列举了11种排序算法，分为4大类，如下

* Simple sorts 简单排序
  * Insertion sort 插入排序
  * Selection sort 选择排序
* Efficient sorts 高效排序
  * Merge sort 归并排序
  * Heapsort 堆排序
  * Quicksort 快速排序
* Bubble sort and variants 冒泡排序及其变体
  * Bubble sort 冒泡排序
  * Shell sort 希尔排序
  * Comb sort 梳排序
* Distribution sort 分配排序
  * Counting sort 计数排序
  * Bucket sort 桶排序
  * Radix sort 基数排序

### 0x01 术语

先来说说术语，有些术语确实理解起来比较晦涩

#### 0x00 比较型排序算法和非比较型排序算法

比较型排序算法（Comparison sorts）

比较型排序算法就是我们一般常用的那几个排序算法，通过**直接比较**数列中两个数的大小来完成排序。

> 摘自[维基百科](https://en.wikipedia.org/wiki/Comparison_sort)：
>
> A **comparison sort** is a type of [sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm) that only reads the list elements through a single abstract comparison operation (often a "less than or equal to" operator or a [three-way comparison](https://en.wikipedia.org/wiki/Three-way_comparison)) that determines which of two elements should occur first in the final sorted list.

非比较型排序算法（Non-comparison sorts）

**不通过直接比较**序列中两个数的大小来完成排序，所有能用非比较型排序算法的序列都能用比较型排序算法完成排序，但**反过来不成立**。

#### 0x01 稳定性(Stability)

假定在待排序的序列中，有两个值是相等的，排序过后，如果这两个相等的值在排序后序列的相对次序保持不变，那么就是稳定的，否则就是不稳定的，如下图：

![](https://bucket.shaoqunliu.cn/image/0151.png )

### 0x02 排序算法比较

仅给出比较型排序算法(Comparison sorts)

| 算法     | 最佳      | 平均    | 最坏    | 空间   | 稳定性 |
| -------- | --------- | ------- | ------- | ------ | ------ |
| 插入排序 | $n$       | $n^2$ | $n^2$  | $1$    | 稳定   |
| 选择排序 | $n^2$     | $n^2$   | $n^2$   | 1      | 不稳定 |
| 归并排序 | $nlog{n}$ | $nlog{n}$ | $nlog{n}$ | n      | 稳定   |
| 堆排序   | $n$      | $nlog{n}$ | $nlog{n}$ | 1      | 不稳定 |
| 快速排序 | $nlog{n}$  | $nlog{n}$ | $n^2$   | $log{n}$ | 都有 |
| 冒泡排序 | $n$ | $n^2$ | $n^2$ | 1 | 稳定 |
| 希尔排序 | $nlog{n}$ | - | $n^{\frac{4}{3}}$ | 1 | 不稳定 |
| 梳排序   | $nlog{n}$ | $n^2$ | $n^2$ | 1 | 不稳定 |

### 0x03 算法实现

#### 0x00 插入排序(Insertion Sort)

![](https://bucket.shaoqunliu.cn/image/0152.gif)

顺便做一个LeetCode题，题目地址: [147. Insertion Sort List](https://leetcode.com/problems/insertion-sort-list/description/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
	ListNode * insertionSortList(ListNode *head) {
		if (head == NULL || head->next == NULL)
		{
			return head;
		}
		for (ListNode *p = head->next, *pLeft = head; p != NULL; pLeft = p, p = p->next)
		{
			if (p->val >= pLeft->val)
			{
				continue;
			}
			for (ListNode *q = head, *qLeft = NULL; q != p; qLeft = q, q = q->next)
			{
				if (p->val < q->val)
				{
					pLeft->next = p->next;
					if (qLeft != NULL)
					{
						ListNode* tmp = qLeft->next;
						qLeft->next = p;
						p->next = tmp;
					}
					else
					{
						p->next = head;
						head = p;
					}
					break;
				}
			}
		}
		return head;
	}
};
```

上面这个写法耗时52ms，当然不是最快的，最快的一个实现是这样的

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode *h = new ListNode(0);
        ListNode *cur = head;
        ListNode *prev = h;
        ListNode *next = NULL;
        while (cur)
        {
            next = cur->next;
            if (!prev || !prev->next || prev->next->val >= cur->val)
                prev = h;
            while (prev->next && prev->next->val < cur->val)
                prev = prev->next;
            cur->next = prev->next;
            prev->next = cur;
            cur = next;
        }
        return h->next;
    }
};
```

它这个算法将原来的链表拆分成2段，左边一段排序好了的，右边一段未排序的。

他这个算法**精妙的地方在于他这个prev这个指针的使用**

这个`prev`在左边经过排序的那一段链表内又将其分为两段，当从右边链表过来一个未排序的数的时候，通过与`prev`这个指针所指向的值进行大小比较，如果小，这个新值插入的位置就在右边开始(`h`指针)到`prev`指针所指向的位置，如果大，`prev`这个指针不动，从`prev`后面开始找插入点，实现了一个**类似于二分查找的方法**来进一步缩小了插入点的位置区间。