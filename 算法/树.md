### 0x00 二叉树

二叉树（Binary tree）是一个以树型存储的数据结构，每个结点除数据域外都有一个左孩子（left child）以及一个右孩子（right child）。

满二叉树（**perfect **binary tree），除最后一层无任何子节点外，每一层上的所有节点都有两个子结点二叉树。另有定义：一棵高度为$h$，并且含有$2^h-1$个节点的二叉树称为满二叉树。此定义与上述定义等价。

完全二叉树（complete binary tree），对于深度为K的有n个结点的二叉树，当且仅当**其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时**称之为完全二叉树。

> 我有必要跟你说一下perfect binary tree和full binary tree的区别，如果按照英文字面来理解的话，full binary tree翻译过来应该是满二叉树，其实不然，这样的字面翻译也是错误的，我们需要依据其具体的定义来理解，国外教材是这样定义full binary tree的：
>
> > A full binary tree (sometimes referred to as a proper or plane binary tree) is a tree **in which every node has either 0 or 2 children**.
>
> 从上述国外教材的原话中我们可以知道只要满足所有节点不是有0个就是有2个子节点的树就可以称为full binary tree，如下图：
>
> ![full binary tree](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183305616-1864401342.png)
>
> 上面这个树在我们国内教材的定义上，不是满二叉树，但其确实对应了国外教材中所述的full binary tree的定义，你可以看到我在满二叉树的定义处指出**国内教材中的满二叉树应对应国外教材中的perfect binary tree**，来让我们看一下国外教材是怎么定义perfect binary tree的：
>
> > A perfect binary tree is a binary tree **in which all interior nodes have two children and all leaves have the same depth or same level**.
>
> 下图即为一个满二叉树，即为perfect binary tree：
>
> ![](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183610632-1388959691.png)
>
> 此处我们要注意了如果一个二叉树是perfect binary tree那他一定是full binary tree，反之不成立。
>
> 在部分国外教材中文译本上，perfect binary tree被翻译为**完美**二叉树，full binary被翻译为**完满**二叉树。
>
> **下文中所有的满二叉树均指国内教材中有关满二叉树的定义，也就是perfect binary tree。**

二叉树常用公式：

1. **非空**二叉树第$i$层上最多有$2^{i-1}$个结点
2. 高度为$h$的二叉树至多有$2^h-1$个结点
3. 第$i$个结点所在的层次（深度）为$\lfloor\log_2{i}\rfloor+1$
4. 具有$N$个结点的完全二叉树的高度为$\lceil\log_2{(N+1)}\rceil$
5. 对于任意二叉树，度为0的结点记为$N_0$，度为2的结点记为$N_2$，则必有$N_0=N_2+1$，即度为0的结点总比度为2的结点多一个

> 注：
>
> $\lfloor x\rfloor$为向下取整符号，结果为不大于x的最大整数，例如$\lfloor2.9\rfloor=2$
>
> $\lceil x\rceil$为向上取整符号，结果为不小于x的最小整数，例如$\lceil2.1\rceil=3$
>
> 树中一个结点的子结点的个数称为结点的度（degree of node），度大于0的结点称为分支结点（branch node），度等于0的结点称为叶子结点（leaf node）或终端结点（terminal node）。

### 0x01 二叉树的遍历

先看一棵树：

![](https://www.ida.liu.se/opendsa/OpenDSA/Books/TDDD86_2014/html/_images/BinExamp.png)

#### 0x00 先序遍历

先序遍历（Preorder Traversal）的遍历过程为先访问根节点，然后递归先序遍历左子树，后递归先序遍历右子树，则对上面的那个树遍历序列应为：

```
ABDCEGFHI
```

我们可以通过LeetCode题目，[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)来练习树的先序遍历过程，在此题中，不需要你手动建树，他会给你建好一个树然后作为函数的输入参数给你，你只需完成先序遍历的过程，然后输出这个序列即可，给出我写的一个基于递归算法的树的先序遍历的代码：

```c++
class Solution {
public:
    std::vector<int> preorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            ret.emplace_back(root->val);
            std::vector<int> left = preorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            std::vector<int> right = preorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
        }
        return ret;
    }
};
```

#### 0x01 中序遍历

中序遍历（Inorder Traversal）先依次中序遍历左子树，然后访问根节点，最后依次中序遍历右子树，则对上面的那个树中序遍历序列应为：

```
BDAGECHFI
```

同样通过LeetCode题目[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)来练习树的中序遍历，基于递归算法的代码如下：

```c++
class Solution {
public:
    std::vector<int> inorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            std::vector<int> left = inorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            ret.emplace_back(root->val);
            std::vector<int> right = inorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
        }
        return ret;
    }
};
```

#### 0x02 后序遍历

后序遍历（Postorder Traversal）的遍历顺序为先后序遍历左子树，然后后序遍历右子树，最后后序遍历根节点。则对于上面的那个树后序遍历序列应为：

```
DBGEHIFCA
```

同样通过LeetCode题目[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)来训练后序遍历的代码，使用递归算法的代码如下：

```c++
class Solution {
public:
    std::vector<int> postorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            std::vector<int> left = postorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            std::vector<int> right = 
                                   postorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
            ret.emplace_back(root->val);
        }
        return ret;
    }
};
```

不知道细心的你有没有发现，在树的前序遍历、中序遍历以及后序遍历我们所写出来的代码中，不一样的地方只有那个`if`块里面语句的顺序调换了一下而已。

#### 0x03 层序遍历

层序遍历（Level Order Traversal）和上面三种就不一样了，层序遍历基本上就是我们人类肉眼的遍历方法，对于上面图中的那个二叉树，层序遍历顺序为：

```
ABCDEFGHI
```

通过LeetCode题目[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)来练习层序遍历的过程，注意此题要求你返回一个`vector<vector<int>>`，输入二叉树的每一层都要单独放在一个`vector`里面，然后把所有层的`vector`都打包在一个`vector`里面返回，使用递归算法实现的代码如下：

```c++
class Solution {

    void levelOrder(std::vector<std::vector<int>> &res, std::vector<TreeNode*> current)
    {
        std::vector<int> nums;
        std::vector<TreeNode*> next;
        for (TreeNode* node : current)
        {
            if (node)
            {
                nums.emplace_back(node->val);
                next.emplace_back(node->left);
                next.emplace_back(node->right);
            }
        }
        if (nums.size())
        {
            res.emplace_back(nums);
        }
        if (next.size())
        {
            levelOrder(res, next);
        }
    }
public:
    std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<TreeNode*> current;
        current.emplace_back(root);
        std::vector<std::vector<int>> res;
        levelOrder(res, current);
        return res;
    }
};
```

这份代码运行时间4ms击败98.92%的人，但此代码使用了递归算法，基本思路为，我每走到一层记录当前这层所有节点的子节点指针（即为下一层节点指针）放在一个`vector`里面，然后将其作为参数递归传下去，然后下一次递归的时候即遍历传入的当前一层的指针列表依次记录其中元素的值，然后插入结果集的`vector`即可。

### 0x02 二叉树的建立

#### 0x00 什么样的遍历顺序组合可以独一地确立一颗二叉树

二叉树有四种遍历方式，先序遍历、中序遍历、后序遍历以及层序遍历，先给定这四种遍历方式中的**任意两个**，通过这两个遍历顺序可以唯一的确定一颗二叉树吗？

答案是：当**给定中序遍历序列以及剩下的三种任意一个的话**，即可**唯一地**确立一颗二叉树。

如果不给定中序遍历序列，而是给定剩下三种遍历序列的组合的话，是不能**唯一地**确立二叉树的，看如下示例：

现有二叉树：

```
  1
 /  
2    
```

给定先序遍历序列为`12`，以及后序遍历序列为`21`，我们可以看出如下两树均可满足相同的先序及后序遍历序列，所以其不能**唯一地**确定二叉树：

```
      1    |     1
    /      |       \
  2        |         2
树1        |         树2
```

但如果给定先序遍历序列为`12`和中序遍历序列`21`，就能唯一地确定所要求得的二叉树为树1，因为树2的中序遍历序列为`12`，就能把结点2牢牢地限制住其为1的左孩子。

如果想求得唯一的二叉树，**必需有中序遍历序列以及剩下三种遍历序列中的任意一个**，如果没有中序遍历序列，剩下的三种遍历序列无论怎么组合，即便三个全部给出也依然无法求得**唯一的二叉树**。

#### 0x01 通过先序遍历和中序遍历建立二叉树

通过LeetCode题目来练习使用先序遍历和中序遍历建立二叉树的过程，题目链接[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)，下面的代码使用递归算法完成，效率自然不高：

```c++
class Solution {
    
    TreeNode * buildTree(std::vector<int>& preorder, int ps, std::vector<int>& inorder, int is, int ie)
    {
        if (ps >= preorder.size() || is >= ie)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(preorder[ps]);
        int i = is;
        for (; i < ie; ++i)
        {
            if (inorder[i] == preorder[ps])
            {
                break;
            }
        }
        root->left = buildTree(preorder, ps + 1, inorder, is, i);
        root->right = buildTree(preorder, ps + i - is + 1, inorder, i + 1, ie);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
        return buildTree(preorder, 0, inorder, 0, inorder.size());
    }
};
```

大致说一下基本的算法思路，对于上面图中的那个二叉树，其先序遍历序列为：

```
ABDCEGFHI
```

中序遍历序列为：

```
BDAGECHFI
```

先序遍历首先访问的为根节点，由先序遍历的序列可知第一个根节点为A，然后我们在中序遍历里面查找A，因题目已经给出条件`You may assume that duplicates do not exist in the tree.`说明树中没有重复元素了，所以我们可以直接在中序遍历的序列里查找根节点A所在的位置，依中序遍历规则可知，A前面的元素BD即为A作为根节点时的左孩子，A后面的元素GECHFI即为A作为根节点时的右孩子，然后再向下递归得到以结点B为根节点的子树，依次递归直至先序遍历序列完成一遍时算法结束。

上面的算法，我们每次递归时都会有一个for循环来查找当前根节点在中序遍历序列中的位置，我们可以使用`unordered_map`将其消除，用空间换时间，在递归之前，我们提前遍历中序遍历序列，将中序遍历的数值作为key和其在vector内的下标作为value，使用`unordered_map`将其一一对应起来，这样我们可以直接使用二叉树遍历的数值（作为`unordered_map`的key）来快速找到其在中序遍历序列中的下标（作为`unordered_map`的value），从而省去了每一次进入使用for循环查找的过程，大大提升了算法的效率，代码如下：

```c++
class Solution {

    std::unordered_map<int, int> iMap;

    TreeNode * buildTree(std::vector<int>& preorder, int ps, std::vector<int>& inorder, int is, int ie)
    {
        if (ps >= preorder.size() || is >= ie)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(preorder[ps]);
        int i = iMap[preorder[ps]];
        root->left = buildTree(preorder, ps + 1, inorder, is, i);
        root->right = buildTree(preorder, ps + i - is + 1, inorder, i + 1, ie);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); ++i)
        {
            iMap[inorder[i]] = i;
        }
        return buildTree(preorder, 0, inorder, 0, inorder.size());
    }
};
```

进行上述优化后，代码的运行时间从20ms缩减到了8ms可见效果还是十分明显的。

#### 0x02 通过中序遍历和后序遍历建立二叉树

通过中序遍历序列和后序遍历序列可以确立一棵唯一的二叉树，我们可以通过LeetCode题目[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)来练习，基于递归算法的代码如下：

```c++
class Solution {

    std::unordered_map<int, int> iMap;

    TreeNode * buildTree(std::vector<int>& inorder, int is, int ie, std::vector<int>& postorder, int ps, int pe)
    {
        if (is >= ie || ps >= pe)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(postorder[pe - 1]);
        int lsize = iMap[postorder[pe - 1]] - is;
        root->left = buildTree(inorder, is, is + lsize, postorder, ps, ps + lsize);
        root->right = buildTree(inorder, iMap[postorder[pe - 1]] + 1, ie, postorder, ps + lsize, pe - 1);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& inorder, std::vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); ++i)
        {
            iMap[inorder[i]] = i;
        }
        return buildTree(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};
```

### 0x03 线索二叉树

在传统的二叉树的实现中，在一棵树中往往由很多空指针，比如在叶子结点中以及在那些缺少某个孩子的结点中，线索二叉树（Threaded Binary Tree）的实质就是为了把这些空指针全部利用起来，利用这些空的指针域来存放**其直接前驱或后继的指针**，**加快查找结点前驱和后继的速度**。

线索二叉树的存储结构：

```c++
struct TreeNode {
    int val;          // 数据域
    TreeNode *left;   // 左孩子
    TreeNode *right;  // 右孩子
    int ltag;         // 左标识域
    int rtag;         // 右标识域
}
```

其标识域含义如下：

* `ltag`
  * 0：`left`指针指向结点的左孩子
  * 1：`left`指针指向结点的前驱
* `rtag`
  * 0：`right`指针指向结点的右孩子
  * 1：`right`指针指向结点的后继

> 这里的前驱和后继是相对于构建线索二叉树的遍历序列而言的。

$N$个结点的线索二叉树含有$N+1$个线索。