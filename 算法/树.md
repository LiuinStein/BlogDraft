### 0x00 二叉树

二叉树（Binary tree）是一个以树型存储的数据结构，每个结点除数据域外都有一个左孩子（left child）以及一个右孩子（right child）。

满二叉树（**perfect **binary tree），除最后一层无任何子节点外，每一层上的所有节点都有两个子结点二叉树。另有定义：一棵高度为$h$，并且含有$2^h-1$个节点的二叉树称为满二叉树。此定义与上述定义等价。

完全二叉树（complete binary tree），对于深度为K的有n个结点的二叉树，当且仅当**其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时**称之为完全二叉树。

> 我有必要跟你说一下perfect binary tree和full binary tree的区别，如果按照英文字面来理解的话full binary tree翻译过来应该是满二叉树，其实不然，国外教材是这样定义full binary tree的：
>
> > A full binary tree (sometimes referred to as a proper or plane binary tree) is a tree **in which every node has either 0 or 2 children**.
>
> 从上述国外教材的原话中我们可以知道只要满足所有节点不是有0个就是有2个子节点的树就可以称为full binary tree，如下图：
>
> ![full binary tree](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183305616-1864401342.png)
>
> 上面这个树我们国内教材的定义上，这不是满二叉树，但其确实对应了国外教材中所述的full binary tree的定义，你可以看到我在满二叉树的定义处指出**国内教材中的满二叉树应对应国外教材中的perfect binary tree**，来让我们看一下国外教材是怎么定义perfect binary tree的：
>
> > A perfect binary tree is a binary tree **in which all interior nodes have two children and all leaves have the same depth or same level**.
>
> 下图即为一个满二叉树，即为perfect binary tree：
>
> ![](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183610632-1388959691.png)
>
> 此处我们要注意了如果一个二叉树是perfect binary tree那他一定是full binary tree，反之不成立。
>
> 在部分国外教材中文译本上，perfect binary tree被翻译为**完美**二叉树，full binary被翻译为**完满**二叉树。
>
> **下文中所有的满二叉树均指国内教材中有关满二叉树的定义，也就是perfect binary tree。**

二叉树常用公式：

1. **非空**二叉树第$i$层上最多有$2^{i-1}$个结点
2. 高度为$h$的二叉树至多有$2^h-1$个结点
3. 第$i$个结点所在的层次（深度）为$\lfloor\log_2{i}\rfloor+1$
4. 具有$N$个结点的完全二叉树的高度为$\lceil\log_2{(N+1)}\rceil$
5. 对于任意二叉树，度为0的结点记为$N_0$，度为2的结点记为$N_2$，则必有$N_0=N_2+1$，即度为0的结点总比度为2的结点多一个

> 注：
>
> $\lfloor x\rfloor$为向下取整符号，结果为不大于x的最大整数，例如$\lfloor2.9\rfloor=2$
>
> $\lceil x\rceil$为向上取整符号，结果为不小于x的最小整数，例如$\lceil2.1\rceil=3$
>
> 树中一个结点的子结点的个数称为结点的度（degree of node），度大于0的结点称为分支结点（branch node），度等于0的结点称为叶子结点（leaf node）或终端结点（terminal node）。

### 0x01 二叉树的遍历

先看一棵树：

![](https://www.ida.liu.se/opendsa/OpenDSA/Books/TDDD86_2014/html/_images/BinExamp.png)

#### 0x00 先序遍历

先序遍历（Preorder Traversal）的遍历过程为先访问根节点，然后递归先序遍历左子树，后递归先序遍历右子树，则对上面的那个树遍历序列应为：

```
ABDCEGFHI
```

我们可以通过LeetCode题目，[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)来练习树的先序遍历过程，在此题中，不需要你手动建树，他会给你建好一个树然后作为函数的输入参数给你，你只需完成先序遍历的过程，然后输出这个序列即可，给出我写的一个基于递归算法的树的先序遍历的代码：

```c++
class Solution {
public:
    std::vector<int> preorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            ret.emplace_back(root->val);
            std::vector<int> left = preorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            std::vector<int> right = preorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
        }
        return ret;
    }
};
```



