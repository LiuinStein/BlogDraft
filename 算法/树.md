### 0x00 二叉树

二叉树（Binary tree）是一个以树型存储的数据结构，每个结点除数据域外都有一个左孩子（left child）以及一个右孩子（right child）。

满二叉树（**perfect **binary tree），除最后一层无任何子节点外，每一层上的所有节点都有两个子结点二叉树。另有定义：一棵高度为$h$，并且含有$2^h-1$个节点的二叉树称为满二叉树。此定义与上述定义等价。

完全二叉树（complete binary tree），对于深度为K的有n个结点的二叉树，当且仅当**其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时**称之为完全二叉树。

> 我有必要跟你说一下perfect binary tree和full binary tree的区别，如果按照英文字面来理解的话，full binary tree翻译过来应该是满二叉树，其实不然，这样的字面翻译也是错误的，我们需要依据其具体的定义来理解，国外教材是这样定义full binary tree的：
>
> > A full binary tree (sometimes referred to as a proper or plane binary tree) is a tree **in which every node has either 0 or 2 children**.
>
> 从上述国外教材的原话中我们可以知道只要满足所有节点不是有0个就是有2个子节点的树就可以称为full binary tree，如下图：
>
> ![full binary tree](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183305616-1864401342.png)
>
> 上面这个树在我们国内教材的定义上，不是满二叉树，但其确实对应了国外教材中所述的full binary tree的定义，你可以看到我在满二叉树的定义处指出**国内教材中的满二叉树应对应国外教材中的perfect binary tree**，来让我们看一下国外教材是怎么定义perfect binary tree的：
>
> > A perfect binary tree is a binary tree **in which all interior nodes have two children and all leaves have the same depth or same level**.
>
> 下图即为一个满二叉树，即为perfect binary tree：
>
> ![](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225183610632-1388959691.png)
>
> 此处我们要注意了如果一个二叉树是perfect binary tree那他一定是full binary tree，反之不成立。
>
> 在部分国外教材中文译本上，perfect binary tree被翻译为**完美**二叉树，full binary被翻译为**完满**二叉树。
>
> **下文中所有的满二叉树均指国内教材中有关满二叉树的定义，也就是perfect binary tree。**

二叉树常用公式：

1. **非空**二叉树第$i$层上最多有$2^{i-1}$个结点
2. 高度为$h$的二叉树至多有$2^h-1$个结点
3. 第$i$个结点所在的层次（深度）为$\lfloor\log_2{i}\rfloor+1$
4. 具有$N$个结点的完全二叉树的高度为$\lceil\log_2{(N+1)}\rceil$
5. 对于任意二叉树，度为0的结点记为$N_0$，度为2的结点记为$N_2$，则必有$N_0=N_2+1$，即度为0的结点总比度为2的结点多一个

> 注：
>
> $\lfloor x\rfloor$为向下取整符号，结果为不大于x的最大整数，例如$\lfloor2.9\rfloor=2$
>
> $\lceil x\rceil$为向上取整符号，结果为不小于x的最小整数，例如$\lceil2.1\rceil=3$
>
> 树中一个结点的子结点的个数称为结点的度（degree of node），度大于0的结点称为分支结点（branch node），度等于0的结点称为叶子结点（leaf node）或终端结点（terminal node）。

### 0x01 二叉树的遍历

先看一棵树：

![](https://www.ida.liu.se/opendsa/OpenDSA/Books/TDDD86_2014/html/_images/BinExamp.png)

#### 0x00 先序遍历

先序遍历（Preorder Traversal）的遍历过程为先访问根节点，然后递归先序遍历左子树，后递归先序遍历右子树，则对上面的那个树遍历序列应为：

```
ABDCEGFHI
```

我们可以通过LeetCode题目，[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)来练习树的先序遍历过程，在此题中，不需要你手动建树，他会给你建好一个树然后作为函数的输入参数给你，你只需完成先序遍历的过程，然后输出这个序列即可，给出我写的一个基于递归算法的树的先序遍历的代码：

```c++
class Solution {
public:
    std::vector<int> preorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            ret.emplace_back(root->val);
            std::vector<int> left = preorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            std::vector<int> right = preorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
        }
        return ret;
    }
};
```

#### 0x01 中序遍历

中序遍历（Inorder Traversal）先依次中序遍历左子树，然后访问根节点，最后依次中序遍历右子树，则对上面的那个树中序遍历序列应为：

```
BDAGECHFI
```

同样通过LeetCode题目[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)来练习树的中序遍历，基于递归算法的代码如下：

```c++
class Solution {
public:
    std::vector<int> inorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            std::vector<int> left = inorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            ret.emplace_back(root->val);
            std::vector<int> right = inorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
        }
        return ret;
    }
};
```

#### 0x02 后序遍历

后序遍历（Postorder Traversal）的遍历顺序为先后序遍历左子树，然后后序遍历右子树，最后后序遍历根节点。则对于上面的那个树后序遍历序列应为：

```
DBGEHIFCA
```

同样通过LeetCode题目[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)来训练后序遍历的代码，使用递归算法的代码如下：

```c++
class Solution {
public:
    std::vector<int> postorderTraversal(TreeNode* root) {
        std::vector<int> ret;
        if (root)
        {
            std::vector<int> left = postorderTraversal(root->left);
            ret.insert(ret.end(), left.begin(), left.end());
            std::vector<int> right = 
                                   postorderTraversal(root->right);
            ret.insert(ret.end(), right.begin(), right.end());
            ret.emplace_back(root->val);
        }
        return ret;
    }
};
```

不知道细心的你有没有发现，在树的前序遍历、中序遍历以及后序遍历我们所写出来的代码中，不一样的地方只有那个`if`块里面语句的顺序调换了一下而已。

#### 0x03 层序遍历

层序遍历（Level Order Traversal）和上面三种就不一样了，层序遍历基本上就是我们人类肉眼的遍历方法，对于上面图中的那个二叉树，层序遍历顺序为：

```
ABCDEFGHI
```

通过LeetCode题目[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)来练习层序遍历的过程，注意此题要求你返回一个`vector<vector<int>>`，输入二叉树的每一层都要单独放在一个`vector`里面，然后把所有层的`vector`都打包在一个`vector`里面返回，使用递归算法实现的代码如下：

```c++
class Solution {

    void levelOrder(std::vector<std::vector<int>> &res, std::vector<TreeNode*> current)
    {
        std::vector<int> nums;
        std::vector<TreeNode*> next;
        for (TreeNode* node : current)
        {
            if (node)
            {
                nums.emplace_back(node->val);
                next.emplace_back(node->left);
                next.emplace_back(node->right);
            }
        }
        if (nums.size())
        {
            res.emplace_back(nums);
        }
        if (next.size())
        {
            levelOrder(res, next);
        }
    }
public:
    std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<TreeNode*> current;
        current.emplace_back(root);
        std::vector<std::vector<int>> res;
        levelOrder(res, current);
        return res;
    }
};
```

这份代码运行时间4ms击败98.92%的人，但此代码使用了递归算法，基本思路为，我每走到一层记录当前这层所有节点的子节点指针（即为下一层节点指针）放在一个`vector`里面，然后将其作为参数递归传下去，然后下一次递归的时候即遍历传入的当前一层的指针列表依次记录其中元素的值，然后插入结果集的`vector`即可。

### 0x02 二叉树的建立

#### 0x00 什么样的遍历顺序组合可以独一地确立一颗二叉树

二叉树有四种遍历方式，先序遍历、中序遍历、后序遍历以及层序遍历，先给定这四种遍历方式中的**任意两个**，通过这两个遍历顺序可以唯一的确定一颗二叉树吗？

答案是：当**给定中序遍历序列以及剩下的三种任意一个的话**，即可**唯一地**确立一颗二叉树。

如果不给定中序遍历序列，而是给定剩下三种遍历序列的组合的话，是不能**唯一地**确立二叉树的，看如下示例：

现有二叉树：

```
  1
 /  
2    
```

给定先序遍历序列为`12`，以及后序遍历序列为`21`，我们可以看出如下两树均可满足相同的先序及后序遍历序列，所以其不能**唯一地**确定二叉树：

```
      1    |     1
    /      |       \
  2        |         2
树1        |         树2
```

但如果给定先序遍历序列为`12`和中序遍历序列`21`，就能唯一地确定所要求得的二叉树为树1，因为树2的中序遍历序列为`12`，就能把结点2牢牢地限制住其为1的左孩子。

如果想求得唯一的二叉树，**必需有中序遍历序列以及剩下三种遍历序列中的任意一个**，如果没有中序遍历序列，剩下的三种遍历序列无论怎么组合，即便三个全部给出也依然无法求得**唯一的二叉树**。

现在考虑一个问题，假设说我只知道前序或后序遍历序列，则符合此遍历序列的二叉树一共有多少呢？由此可延伸一个相同的问题，$N$个结点可以构成多少种不同的二叉树，此题答案依然为卡特兰数公式：
$$
\frac{1}{N+1}C_{2N}^{N}
$$

#### 0x01 通过先序遍历和中序遍历建立二叉树

通过LeetCode题目来练习使用先序遍历和中序遍历建立二叉树的过程，题目链接[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)，下面的代码使用递归算法完成，效率自然不高：

```c++
class Solution {
    
    TreeNode * buildTree(std::vector<int>& preorder, int ps, std::vector<int>& inorder, int is, int ie)
    {
        if (ps >= preorder.size() || is >= ie)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(preorder[ps]);
        int i = is;
        for (; i < ie; ++i)
        {
            if (inorder[i] == preorder[ps])
            {
                break;
            }
        }
        root->left = buildTree(preorder, ps + 1, inorder, is, i);
        root->right = buildTree(preorder, ps + i - is + 1, inorder, i + 1, ie);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
        return buildTree(preorder, 0, inorder, 0, inorder.size());
    }
};
```

大致说一下基本的算法思路，对于上面图中的那个二叉树，其先序遍历序列为：

```
ABDCEGFHI
```

中序遍历序列为：

```
BDAGECHFI
```

先序遍历首先访问的为根节点，由先序遍历的序列可知第一个根节点为A，然后我们在中序遍历里面查找A，因题目已经给出条件`You may assume that duplicates do not exist in the tree.`说明树中没有重复元素了，所以我们可以直接在中序遍历的序列里查找根节点A所在的位置，依中序遍历规则可知，A前面的元素BD即为A作为根节点时的左孩子，A后面的元素GECHFI即为A作为根节点时的右孩子，然后再向下递归得到以结点B为根节点的子树，依次递归直至先序遍历序列完成一遍时算法结束。

上面的算法，我们每次递归时都会有一个for循环来查找当前根节点在中序遍历序列中的位置，我们可以使用`unordered_map`将其消除，用空间换时间，在递归之前，我们提前遍历中序遍历序列，将中序遍历的数值作为key和其在vector内的下标作为value，使用`unordered_map`将其一一对应起来，这样我们可以直接使用二叉树遍历的数值（作为`unordered_map`的key）来快速找到其在中序遍历序列中的下标（作为`unordered_map`的value），从而省去了每一次进入使用for循环查找的过程，大大提升了算法的效率，代码如下：

```c++
class Solution {

    std::unordered_map<int, int> iMap;

    TreeNode * buildTree(std::vector<int>& preorder, int ps, std::vector<int>& inorder, int is, int ie)
    {
        if (ps >= preorder.size() || is >= ie)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(preorder[ps]);
        int i = iMap[preorder[ps]];
        root->left = buildTree(preorder, ps + 1, inorder, is, i);
        root->right = buildTree(preorder, ps + i - is + 1, inorder, i + 1, ie);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); ++i)
        {
            iMap[inorder[i]] = i;
        }
        return buildTree(preorder, 0, inorder, 0, inorder.size());
    }
};
```

进行上述优化后，代码的运行时间从20ms缩减到了8ms可见效果还是十分明显的。

#### 0x02 通过中序遍历和后序遍历建立二叉树

通过中序遍历序列和后序遍历序列可以确立一棵唯一的二叉树，我们可以通过LeetCode题目[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)来练习，基于递归算法的代码如下：

```c++
class Solution {

    std::unordered_map<int, int> iMap;

    TreeNode * buildTree(std::vector<int>& inorder, int is, int ie, std::vector<int>& postorder, int ps, int pe)
    {
        if (is >= ie || ps >= pe)
        {
            return nullptr;
        }
        TreeNode *root = new TreeNode(postorder[pe - 1]);
        int lsize = iMap[postorder[pe - 1]] - is;
        root->left = buildTree(inorder, is, is + lsize, postorder, ps, ps + lsize);
        root->right = buildTree(inorder, iMap[postorder[pe - 1]] + 1, ie, postorder, ps + lsize, pe - 1);
        return root;
    }
public:
    TreeNode * buildTree(std::vector<int>& inorder, std::vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); ++i)
        {
            iMap[inorder[i]] = i;
        }
        return buildTree(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};
```

### 0x03 线索二叉树

#### 0x00 基本概念

在传统的二叉树的实现中，在一棵树中往往由很多空指针，比如在叶子结点中以及在那些缺少某个孩子的结点中，线索二叉树（Threaded Binary Tree）的实质就是为了把这些空指针全部利用起来，利用这些空的指针域来存放**其直接前驱或后继的指针**，**加快查找结点前驱和后继的速度**。线索化的实质就是设法利用二叉树中多余的空指针将二叉树变为一个双向链表。

二叉树为一种**逻辑结构**，线索二叉树是加上线索后的链表结构，也就是说，它是二叉树在计算机内部的一种存储结构，所以**线索二叉树是一种物理结构**。

线索二叉树的存储结构：

```c++
struct TreeNode {
    int val;          // 数据域
    TreeNode *left;   // 左孩子
    TreeNode *right;  // 右孩子
    int ltag;         // 左标识域
    int rtag;         // 右标识域
}
```

其标识域含义如下：

* `ltag`
  * 0：`left`指针指向结点的左孩子
  * 1：`left`指针指向结点的前驱
* `rtag`
  * 0：`right`指针指向结点的右孩子
  * 1：`right`指针指向结点的后继

> 这里的前驱和后继是相对于构建线索二叉树的遍历序列而言的。

$N$个结点的线索二叉树含有$N+1$个线索。

在先序线索树、中序线索树和后序线索树三者之中，**后序线索树的遍历仍然需要栈的支持**，后序线索树在进行遍历时，最后访问根节点，如果从右孩子x返回访问父节点，则此节点的右孩子不一定为空（右指针无法指向其后序遍历的后继），因此后序线索树可能通过指针无法遍历整个二叉树，则需要栈的支持。而先序和中序线索树则不必。由此可延伸一个问题即为，**使用后序遍历线索化后的二叉树仍不能有效求解后序后继节点**。

#### 0x01 建立中序线索二叉树

如下为基于递归算法的中序线索二叉树的建立，函数的参数为需要线索化的二叉树的根节点，代码如下：

```c++
struct TreeNode {
    int val;
    bool ltag; // false: left child, true: previous
    bool rtag; // false: right child, true: succeed
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), ltag(false), rtag(false), left(nullptr), right(nullptr) {}
};

class Solution {

    void inThreading(TreeNode *root, TreeNode *&pre)
    {
        if (root)
        {
            inThreading(root->left, pre); // 线索化左子树
            if (!root->left)
            {
                root->left = pre;
                root->ltag = true;
            }
            if (pre && !pre->right)
            {
                pre->right = root;
                pre->rtag = true;
            }
            pre = root;
            inThreading(root->right, pre); // 线索化右子树
        }
    }
public:
    TreeNode * convertToThreadedTreeWithInorderTraversal(TreeNode *root)
    {
        TreeNode *pre = nullptr;
        inThreading(root, pre);
        return root;
    }
};
```

#### 0x02 建立后序线索二叉树

如下为建立后序线索二叉树的代码，仅变动了中序线索二叉树代码的递归顺序：

```c++
// 二叉树结点的存储结构参考建立中序线索二叉树的代码

class Solution {

    void inThreading(TreeNode *root, TreeNode *&pre)
    {
        if (root)
        {
            inThreading(root->left, pre);
            inThreading(root->right, pre);
            if (!root->left)
            {
                root->left = pre;
                root->ltag = true;
            }
            if (pre && !pre->right)
            {
                pre->right = root;
                pre->rtag = true;
            }
            pre = root;
        }
    }
public:
    TreeNode * convertToThreadedTreeWithPostorderTraversal(TreeNode *root)
    {
        TreeNode *pre = nullptr;
        inThreading(root, pre);
        return root;
    }
};
```

### 0x04 树、森林与二叉树之间的相互转换

#### 0x00 树转化为二叉树

1. 树中所有带有相同双亲的兄弟结点之间加一条连线
2. 对树中不是双亲结点的第一个孩子的结点，只**保留新添加的该结点与左兄弟结点之间的连线**，删去该节点与双亲结点之间的连线

![](https://bucket.shaoqunliu.cn/image/0166.jpg)

> 看上图是要注意的一点就是：E和F，在变化之后，F由原来E的兄弟结点变为E的右孩子。

#### 0x01 二叉树转化为树

1. 若某结点是其双亲结点的左孩子，则把该结点的右孩子，右孩子的右孩子等等等等都与这些结点的双亲结点连起来
2. 删除原二叉树中所有双亲结点与右孩子结点的连线

![](https://bucket.shaoqunliu.cn/image/0167.jpg)

#### 0x02 二叉树转化为森林

如果一颗二叉树有右孩子，那么他可以转换为森林，否则，其只能转化为一棵树。

1. 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除
2. 再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除
3. 循环往复直到所有这些根节点与右孩子的连线都删除为止
4. 然后将分离的二叉树全部转化为树

![](https://bucket.shaoqunliu.cn/image/0168.png)

高度为$h$的满二叉树转换为森林后所含树的个数一定为$h$。此处要注意**二叉树转换成的树或森林是唯一的**。

#### 0x03 森林转化为二叉树

1. 将森林中的每棵树变为二叉树
2. 因为转换所得的二叉树的根结点的右子树均为空，故可将各二叉树的根结点视为兄弟从左至右连在一起，就形成了一棵二叉树

![](https://bucket.shaoqunliu.cn/image/0169.png)

### 0x05 二叉排序树（又名二叉搜索树或二叉查找树）

二叉排序树，又名二叉搜索树或二叉查找树，在英文里一般将其称为Binary Search Tree，简写为BST，二叉排序树要么为空树，要么具有如下的三大基本特征：

* 若左子树非空，则**左**子树上所有结点的关键字值均**小**于根节点的关键字值
* 若右子树非空，则**右**子树上所有结点的关键字值均**大**于根节点的关键字值
* 左右子树本身分别也是一颗二叉排序树

因为总有左子树的值<根节点的值<右子树的值，所以对其进行中序遍历总能得到一个递增的有序序列。

#### 0x00 二叉排序树的插入

从一道LeetCode题目说起，[701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/description/)，此题目要求我们在一颗即成二叉排序树内插入一个元素，使用递归算法，我们可以清晰地得到整个的流程，如下：

```c++
class Solution {

public:
    TreeNode * insertIntoBST(TreeNode* root, int val) {
        if (!root)
        {
            return new TreeNode(val);
        }
        if (root->val < val)
        {
            root->right = insertIntoBST(root->right, val);
        }
        else if (root->val > val)
        {
            root->left = insertIntoBST(root->left, val);
        }
        return root;
    }
};
```

由此可见，**新插入的结点一定是叶子结点**，如果树中存在相同的元素，那么就将其忽略，如果新插入的元素大于当前结点的值就将其插入到当前结点的右子树中，如果小于就将其插入当前结点的左子树中，递归往复。

递归虽然可以将算法的流程直观地体现出来，但是递归的效率终究不高，上述代码运行时间60ms仅超过了48.11%的人，我们设法将递归消除掉，我一开始惯性思维下写了一个带栈的消除递归的方法，代码如下：

```c++
class Solution {

public:
    TreeNode * insertIntoBST(TreeNode* root, int val) {
        std::stack<TreeNode*> stk;
        TreeNode **target{ &root };
        TreeNode *dummy{ root };
        while (dummy)
        {
            if (dummy->val < val)
            {
                stk.push(dummy->right);
                target = &dummy->right;
            }
            else if (dummy->val > val)
            {
                stk.push(dummy->left);
                target = &dummy->left;
            }
            else
            {
                return root;
            }
            dummy = stk.top();
            stk.pop();
        }
        *target = new TreeNode(val);
        return root;
    }
};
```

上面的代码运行时间为44ms，击败了98.93%的人，消除递归确实有效地提升了程序的运行效率，后来我发现那个栈最大长度为1，既然这样我们就可以将那个栈消除掉，代码如下：

```c++
class Solution {

public:
    TreeNode * insertIntoBST(TreeNode* root, int val) {
        TreeNode *next;
        TreeNode **target{ &root };
        TreeNode *dummy{ root };
        while (dummy)
        {
            if (dummy->val < val)
            {
                next = dummy->right;
                target = &dummy->right;
            }
            else if (dummy->val > val)
            {
                next = dummy->left;
                target = &dummy->left;
            }
            else
            {
                return root;
            }
            dummy = next;
        }
        *target = new TreeNode(val);
        return root;
    }
};
```

上述的代码运行效率应该和用栈的那个代码差不多才对啊，但是上述代码提交上去之后，运行时间居然为80ms，比递归算法的效率还要差，感觉是其编译器优化出现了问题。

#### 0x01 二叉排序树的删除

二叉排序树删除某个结点时，必须先把被删除结点从存储二叉树的链表中摘下，然后将其左子树和右子树与断开的二叉链表重新连接，并且要保持二叉树的性质不会丢失，可以分三种情况去讨论：

* 如果被删除的结点为叶子结点，那将其直接删除，并不会破坏二叉树的性质

* 如果被删除的结点仅有左子树或者右子树，则让其子树直接代替被删除的结点

* 如果被删除的结点同时存在左子树和右子树，用被删除节点的直接前驱或者直接后继来替换当前节点，调整直接前驱或者直接后继的位置，如图：

  ![](https://bucket.shaoqunliu.cn/image/0170.jpg)

  在上图中，我们要删除47结点，这个结点既有左孩子又有右孩子，我们首先看其中序遍历的序列：

  ```
  29, 35, 36, 37, 47, 48, 49, 50, 51, 56, 58, 62, 73, 88, 93, 99
  ```

  要删除的结点47的直接前驱为37，所以我们把37拿上去换掉被删除的47，这样就转换成了第一或第二种状况，然后再依第一第二种状况处理即可。

通过LeetCode题目[450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/description/)来练习上述过程，如果一个结点既有左孩子又有右孩子，此题接受使用其直接前驱或后序两种序列，如下：

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.  // 使用其直接后继取代被删除的结点

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].
// 使用其直接前驱取代被删除的结点

    5
   / \
  2   6
   \   \
    4   7
// 两种答案均可
```

基于递归算法的代码如下：

```c++
class Solution {

public:
    TreeNode * deleteNode(TreeNode* root, int key) {
        if (!root)
        {
            return nullptr;
        }
        if (root->val > key)
        {
            root->left = deleteNode(root->left, key);
        }
        else if (root->val < key)
        {
            root->right = deleteNode(root->right, key);
        }
        else
        {
            if (root->left && root->right)
            {
                TreeNode *next = root->right;
                while (next->left)
                {
                    next = next->left;
                }
                std::swap(root->val, next->val);
                root->right = deleteNode(root->right, key);
            }
            else if (root->left || root->right)
            {
                TreeNode *ret = 
                              root->left ? root->left : root->right;
                delete root;
                return ret;
            }
            else
            {
                delete root;
                return nullptr;
            }
        }
        return root;
    }
};
```

此代码运行时间16ms，超过100%的人，在删除时将其分为了三种情况，如果：

* 其同时具有左右孩子，那寻找其中序遍历的直接后继，然后交换当前结点与其直接后继的值，将其进一步转换为下面的两种情况，继续递归
* 其仅具有一个孩子，那就用其仅具有的这个孩子来代替这个结点即可
* 其为叶子结点，直接将其删除，不对二叉排序树的性质产生任何的影响

#### 0x02 二叉排序树的查找

我们先看一道LeetCode题目，[700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/description/)，此题为简单题，先将其AC掉，然后我们再来分析效率，代码如下：

```c++
class Solution {
public:
    TreeNode * searchBST(TreeNode* root, int val) {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root->val > val)
        {
            return searchBST(root->left, val);
        }
        else if (root->val < val)
        {
            return searchBST(root->right, val);
        }
        return root;
    }
};
```

对于高度为$H$的二叉排序树，其插入和删除操作的运行时间都是$O(H)$，但在其最坏情况下，当输入序列为一个有序序列时，构造二叉排序树会使得形成的树为一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增大为输入元素的个数$N$，由此可见，**二叉排序树的查找效率取决于树的深度**，树的深度越低查找效率越快。如果一棵二叉排序树的形状为仅有左（右）孩子的单支树，其查找的效率和单链表查找的效率就基本一样了。

整体看来，二叉排序树的查找过程和二分查找差不多，而且两者的平均 性能也不相上下，但是二分查找时其判定树是唯一的，二叉排序树则不一定唯一。但是相比较于二分查找有序数组的情况，当插入或删除一个数据时，有序数组的复杂度为$O(N)$，而二叉排序树则无需移动结点，只需移动指针即可完成插入和删除操作，平均的执行时间为$O(\log_2(N))$，所以在我们选择存储结构时，若当有序表为静态查找表（不会对齐进行频繁的插入删除操作的有序表）时，则适宜使用顺序表作为其存储结构，若有序表时动态查找表，则应选择二叉排序树作为其逻辑结构。

### 0x06 平衡二叉树

#### 0x00 基本概念

上一节刚刚说过二叉排序树的性能取决于树的高度，树越高，二叉排序树的性能越差，为了避免树的高度增长地过快，降低二叉排序树的性能，而我们要**保证树的任意结点的左右子树高度差的绝对值不超过1**，这样的树称为平衡二叉树（Self-balancing binary search tree或Balanced binary tree或AVL）。

> 注：AVL是最早实现的一种自平衡二叉搜索树，AVL的全称为**A**delson-**V**elskii and **L**andis，这是以AVL树的三个创始人的名字首字母命名的，就像RSA算法一样。但有些国内的教材上会将平衡二叉树和AVL树放在一起谈，甚至说平衡二叉树就是AVL树，这样的说法是不严谨的，严格来说，AVL树是平衡二叉树的一种。

平衡二叉树要么是空树，要么满足如下的2个特征：

* 其左子树和右子树均为平衡二叉树
* 左子树和右子树高度差的绝对值不超过1

#### 0x01 平衡二叉树的判定

下图为一棵平衡二叉树：

![](https://www.cs.auckland.ac.nz/software/AlgAnim/fig/AVL_extreme.gif)

而下图则不是：

![](https://www.cs.auckland.ac.nz/software/AlgAnim/fig/AVL1a.gif)

原因是以8为根节点的子树的高度为4，而以18为结点的子树高度为2，两者的高度差为2大于1，所以其不是平衡二叉树。

如下也不是一棵平衡二叉树：

![](https://bucket.shaoqunliu.cn/image/0171.png)

因为结点2的左子树高度为2，右子树高度为0，两者之差的绝对值大于1。

我们可以通过LeetCode题目[110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/description/)来练习使用程序来判定一棵给定的二叉树是否为平衡二叉树，代码如下：

```c++
class Solution {

    int depth(TreeNode *root)
    {
        if (!root)
        {
            return 0;
        }
        return std::max(depth(root->left) + 1, depth(root->right) + 1);
    }
public:
    bool isBalanced(TreeNode* root) {
        return !root || 
            std::abs(depth(root->left) - depth(root->right)) < 2 &&
            isBalanced(root->left) && isBalanced(root->right);
    }
};
```

### 0x07 二叉树的高度和宽度

#### 0x00 求二叉树的最大高度

我们可以使用如下LeetCode题目来练习求二叉树的最大高度，[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)，基于递归算法的代码如下：

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root)
        {
            return 0;
        }
        return std::max(maxDepth(root->left) + 1, maxDepth(root->right) + 1);
    }
};
```

#### 0x01 求二叉树的最大宽度

做了一道LeetCode题目[662. Maximum Width of Binary Tree](https://leetcode.com/problems/maximum-width-of-binary-tree/description/)，此题要求你找出二叉树最长的那一行的长度，而且所求的长度不仅包括有效节点的长度，而且还要将有效节点之间为null的那些元素也算进去，例如：

```
Input: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7)
```

我一开始写了如下的代码：

```c++
class Solution {

public:
    int widthOfBinaryTree(TreeNode* root) {
        int max{};
        std::vector<TreeNode*> current;
        current.emplace_back(root);
        std::vector<TreeNode*> next;
        int count{};
        do
        {
            count = 0;
            int countBegin{}, null{};
            for (TreeNode *node : current)
            {
                if (node)
                {
                    count += 1 + null;
                    null = 0;
                    countBegin = 1;
                    next.emplace_back(node->left);
                    next.emplace_back(node->right);
                }
                else
                {
                    null += countBegin;
                    next.emplace_back(nullptr);
                    next.emplace_back(nullptr);
                }
            }
            if (count)
            {
                if (count > max)
                {
                    max = count;
                }
                current = next;
                next.clear();
            }
        }
        while (count);
        return max;
    }
};
```

上面的代码，在第104/108组测试用例中超内存，第104组测试用例相当的大，最长的宽度有178535个结点（输出结果）。然后就导致Memory Limit Exceeded，很伤心。

