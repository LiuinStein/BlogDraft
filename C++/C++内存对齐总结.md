### 0x00 C++ 内存管理机制

#### 0x00 内存布局

如图：

![](https://bucket.shaoqunliu.cn/image/0162.jpg)

从低地址到高地址（从下往上）依次为：

1. **Text Segment（代码段）:** 英文也可以写为code segment，包含了程序的可执行代码，通常此段是**可共享的**，以便同样的可执行代码只需要在内存中存储一遍，同时此段是**只读的**，以防止程序分配内存时将其覆写。

2. **Initialized Data Segment（初始化数据段）:** 有时英文也简写为data segment，用来存放程序的**全局变量**以及**静态变量**， 此段可进一步被分为初始化只读区域（initialized read-only area）以及初始化可写区域（initialized read-write area），例如如下两个全局变量：

   ```c++
   const char * str = "Hello World";  // 将会存储在初始化只读区域
   char * str = "Hello World";  // 将会存储在初始化可写区域
   ```

3. **Uninitialized Data Segment（未初始化数据段）:** 又称为bss段，此段数据将会在程序开始执行以前被内核初始化为0，此段包含了所有未在程序代码中显式初始化的全局变量和静态变量，例如：

   ```c++
   static int i;  // 未被显式初始化的静态变量
   ```

4. **Heap（堆区）:**  动态分配内存时所使用的区，也就是在C语言中使用malloc函数开辟free函数回收的内存区域，或者在C++中使用new关键字开辟、delete关键字回收的内存区域。**堆区从低地址向高地址增长**。

5. **Stack（栈区）:** **栈从高地址向低地址增长**，如果栈顶指针与堆顶指针相遇，那么就没有剩余的内存空间可以继续分配了（不考虑虚拟内存技术将部分内存内容转移至硬盘中存储）。栈区存放的是程序栈（program stack），是一个LIFO（Last In First Out后进先出）的数据结构。
   栈区存放局部变量（automatic variables又称自动变量），当一个函数被调用时，返回值的地址以及调用时传递的参数信息就会被存储在栈中，然后新调用的函数将会在栈中分配局部变量的存储空间。同时，程序将会为每一次函数调用分配一个新的栈帧（stack frame）。

#### 0x01 堆与栈的区别

1. 管理方式不同：栈由编译器自动管理，堆的开辟与释放需要程序员的控制，此过程容易产生memory leak。
2. 空间大小不同：对于ARM、x86以及x64机器，栈的默认大小是1MB（此处参考[/STACK (Stack Allocations) - MSDN文档](https://docs.microsoft.com/zh-cn/cpp/build/reference/stack-stack-allocations)），当然我们也可以通过编译器参数`/STACK`自行设置其大小，堆在32位系统下最大可以达到4GB的空间。
3. 碎片问题：频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，因为在他弹出之前，在他上面的后进的栈内容已经被弹出了。
4. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 
5. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由`alloca`函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 
6. 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就注定了栈的效率比较高。 堆分配的机制较为复杂，一般由C/C++的函数库来进行支持，为了分配一块特定大小的内存往往需要先在堆内存中搜索可用的足够大小的空间（考虑碎片问题），如果没有足够大小的空间（例如碎片过多），就可能会通过调用系统功能来进行碎片整理来增加程序可用的空间大小，然后进行返回，可见堆的使用效率要比栈低得多。

### 0x0 参考文献

[Memory Layout of C Programs - GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/)

[/STACK (Stack Allocations) - MSDN文档](https://docs.microsoft.com/zh-cn/cpp/build/reference/stack-stack-allocations)