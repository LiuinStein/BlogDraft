### 0x00 数据结构

#### 0x00 数组

##### 0x00 位置和地址

位置是指的第几个位置，而地址指的是数据的起始地址，例如

若二维数组a有m列，则计算任一元素`a[i][j]`在数组中的**位置**为`i*m + j + 1`，其**地址**为`i*m + j`

#### 0x01 字符串

##### 0x00 子串 非空子串 非空真子串

一个长度为n的字符串：

有$\frac{n(n+1)}{2}+1$个子串，$\frac{n(n+1)}{2}$个非空子串，$\frac{n(n+1)}{2}-1$个非空真子串

> 字符串ABC的子串有7个：
>
> "", "A", "B", "C", "AB", "BC", "ABC"
>
> 非空子串有6个：
>
> "A", "B", "C", "AB", "BC", "ABC"
>
> 非空真子串有5个：
>
> "A", "B", "C", "AB", "BC"

#### 0x02 链表



##### 0x0 其他注意事项

* 在**单链表的末尾进行删除操作，有尾指针没用啊**，删除操作需要知道尾指针前面的那一个数据

#### 0x03 栈

##### 0x00 前缀中缀后缀表达式

中缀式就是最常见的数学表达式，如下：

```
A+B*(C-(D+F))/E
```

前缀式（又称**波兰式**），前缀表达式运算符位于操作数**之前**

后缀式（又称**逆波兰式**），运算符位于操作数之后

其三者的互相转化可以通过画二叉树来完成，例如使用上述的中缀式画二叉树，要注意**根节点上总是运算符，运算符也总是在根节点上**，结果如下：

![](https://bucket.shaoqunliu.cn/image/0243.png)

此时中缀表达式就是上图二叉树的中序遍历结果，其转化而成的前缀和后缀表达式就是上述二叉树的前序和后序遍历序列。

求解转换过程中扫描到某一项时，栈中的元素：

**中缀式转换为前缀式栈中元素变化过程**：

* **从右到左**
* 遇到数字直接输出
* 遇到运算符
  * 若优先级比栈顶运算符的较高或相等，也将运算符压入
  * 否则，将S1栈顶的运算符弹出
  * 若栈顶为空或者为）则直接将其入栈
  * 遇到（则一直退栈直到遇到一个）为止

**中缀式转换为后缀式栈中元素变化过程**：

* **从左到右**
* 遇到数字直接输出
* 遇到运算符
  * 如果当前运算符比栈顶位置的运算符优先级低那就先出栈再进栈
  * 如果高那就直接入栈
  * 遇到（直接入栈，遇到）一直退栈直到遇到一个（为止

#### 0x04 队列



#### 0x05 树



#### 0x06 图



##### 0x0 其他注意事项

别**邻接表和邻接矩阵**分不清，一个是基于链表的，另一个是基于顺序存储结构数组

#### 0x07 哈希



#### 0x08 堆



#### 0x09 查找



#### 0x0A 排序

##### 0x00 一趟快排
给定一序列和一基数，求出其一趟快排后的序列，例如：

使用快速排序算法对序列9,1,3,8,23,5,7,10,29,19进行排序，基准数取9，则第一趟排序后的结果为：

7,1,3,8,5,9,23,10,29,19

1. 先**从后往前**搜索小于9的数和9交换得到:  7,1,3,8,23,5,9,10,29,19
2. 再**从前往后**搜索大于9的数和9交换得到:  7,1,3,8,9,5,23,10,29,19
3. 再**从后往前**搜索小于9的数和9交换得到:  7,1,3,8,5,9,23,10,29,19

现在9之前没有比9大的数了，9之后没有比9小的数了，一趟快排完成

#### 0x0B 递归



#### 0x0C 复杂度



#### 0x0D 高级算法



#### 0x0E 常见函数

```c++
/*
 * 第一个参数为复制到
 * 第二个参数为源
 * 操作成功返回dst，失败返回NULL
 */
char *strcpy(char *dst, const char *src);
```

### 0x01 操作系统



### 0x02 计算机网络