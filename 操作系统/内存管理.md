### 0x00 内存管理

#### 0x00 内存管理的主要功能

* 内存空间的分配与回收
* 地址转换：在多道程序的环境下，程序中的逻辑地址和物理地址不可能一致，因此必需提供地址转换功能，**把逻辑地址转换为对应的物理地址**。
* 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，在**逻辑上**扩充内存
* 存储保护：保证各个作业在自己的存储空间运行，互不干扰

#### 0x01 内存的装入模块装入内存的方式

* **绝对装入**：编译时如果知道程序将驻留在内存的某个位置，那么编译程序可以将产生的绝对地址的目标代码绝对装入程序按照装入模块中的地址，将程序和数据装入内存。**绝对装入仅适用于单道程序环境**。
* **可重定位装入**：多道程序的环境下，多个目标模块的起始地址都是从0开始的，程序中其他地址都是相对于起始地址的，此时应采用可重定位装入方式，根据内存当前的状况将装入模块装入到内存适当的位置，**装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位**。静态重定位的一个特点是**在一个作业装入内存时，必需分配其要求的全部内存空间**。作业一旦进入内存之后，**整个运行期间就不能在内存中挪动，也不能再申请内存空间**。
* **动态运行时装入**：也成为动态重定位，装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此装入内存后的所有地址均为相对地址，这种方式需要一个**重定位寄存器**支持。重定位寄存器中保存着程序的相对地址与内存中的物理地址之间的偏移量。使用时将相对地址与重定位寄存器中的地址相加即可得到其物理地址。**动态重定位的特点是其可以将程序分配到不连续的存储区中**，可以提供一个比存储空间大得多的地址空间。

#### 0x02 内存保护

内存分配前需要保护操作系统不受用户进程影响，同时保护用户进程不受其他用户进程影响，可采用如下两种方法：

* 在CPU内设置一对上下限寄存器，存放用户作业在主存中的上下限地址，每当CPU访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
* 通过使用重定位寄存器和界地址寄存器（限长寄存器）来实现这种保护，重定位寄存器含**最小的物理地址**，界地址寄存器含**逻辑地址的最大值**。每个逻辑地址必需小于界地址寄存器，内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如未发生越界，则加上重定位寄存器的值后映射成物理地址，然后再送交内存单元。

#### 0x03 覆盖与交换

覆盖的基本思想是：程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定去，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

覆盖的特点是：**打破了必须将一个进程的全部信息装入主存后才能运行的限制**，但当同时运行程序的代码量大于主存时仍不能运行，再而，**内存中能够更新的地方只有覆盖区的段**，不在覆盖区的段会常驻内存。

交换的基本思想是：把处于等待状态的程序从内存中转移到辅存，把内存空间换出来，把准备好竞争CPU运行的程序从辅存转移到内存。

有关交换需注意到如下几个问题：

* 交换需要**备份存储**，通常是足够大的快速磁盘，并提供对这些内存映像直接访问
* 为了有效使用CPU，需**每个进程的执行时间比交换时间长**，而且影响交换时间的主要是转移时间，**转移时间与所交换的内存空间成正比**。
* 如果换出进程，则必须确保该进程是完全处于空闲状态。
* 交换空间作为磁盘的一整块，而且独立于文件系统，使用可能较快
* 交换通常在**有许多进程运行且内存空间吃紧时启动**，在系统负荷降低时暂停

交换技术主要在**不同进程之间进行**，而覆盖则用于**同一进程中**。交换技术较为常用，覆盖技术已经基本成为历史。