### 0x00 内存管理

#### 0x00 内存管理的主要功能

* 内存空间的分配与回收
* 地址转换：在多道程序的环境下，程序中的逻辑地址和物理地址不可能一致，因此必需提供地址转换功能，**把逻辑地址转换为对应的物理地址**
  在**链接阶段**完成重定位形成整个程序的完整逻辑空间，在**装载阶段**完成重定位，形成整个程序的完整逻辑地址空间
* 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，在**逻辑上**扩充内存
* 存储保护：保证各个作业在自己的存储空间运行，互不干扰

#### 0x01 内存的装入模块装入内存的方式

* **绝对装入**：编译时如果知道程序将驻留在内存的某个位置，那么编译程序可以将产生的绝对地址的目标代码绝对装入程序按照装入模块中的地址，将程序和数据装入内存。**绝对装入仅适用于单道程序环境**。
* **可重定位装入**：也称**静态重定位**，多道程序的环境下，多个目标模块的起始地址都是从0开始的，程序中其他地址都是相对于起始地址的，此时应采用可重定位装入方式，根据内存当前的状况将装入模块装入到内存适当的位置，**装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位**。静态重定位的一个特点是**在一个作业装入内存时，必需分配其要求的全部内存空间**。作业一旦进入内存之后，**整个运行期间就不能在内存中挪动，也不能再申请内存空间**。
* **动态运行时装入**：也称**动态重定位**，装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此装入内存后的所有地址均为相对地址，这种方式需要一个**重定位寄存器**支持。重定位寄存器中保存着程序的相对地址与内存中的物理地址之间的偏移量。使用时将相对地址与重定位寄存器中的地址相加即可得到其物理地址。**动态重定位的特点是其可以将程序分配到不连续的存储区中**，可以提供一个比存储空间大得多的地址空间。**动态重定位在进程的执行过程进行**。
  **整个系统中设置一个重定位寄存器即可**，因为系统的处理机在同一时刻只能执行一条指令或访问数据，所以为每道程序设置一个寄存器是没有必要的，只需要在切换程序执行时重置寄存器内容即可。

#### 0x02 内存保护

内存分配前需要**保护操作系统不受用户进程影响，同时保护用户进程不受其他用户进程影响**，内存保护需要**操作系统和硬件机构合作完成**，可采用如下两种方法：

* 在CPU内设置一对上下限寄存器，存放用户作业在主存中的上下限地址，每当CPU访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
* 通过使用重定位寄存器和界地址寄存器（限长寄存器）来实现这种保护，重定位寄存器含**最小的物理地址**，界地址寄存器含**逻辑地址的最大值**。每个逻辑地址必需小于界地址寄存器，内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如未发生越界，则加上重定位寄存器的值后映射成物理地址，然后再送交内存单元。

#### 0x03 覆盖与交换

覆盖的基本思想是：程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定去，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

覆盖的特点是：**打破了必须将一个进程的全部信息装入主存后才能运行的限制**，但当同时运行程序的代码量大于主存时仍不能运行，再而，**内存中能够更新的地方只有覆盖区的段**，不在覆盖区的段会常驻内存。

交换的基本思想是：把处于等待状态的程序从内存中转移到辅存，把内存空间换出来，把准备好竞争CPU运行的程序从辅存转移到内存。

有关交换需注意到如下几个问题：

* 交换需要**备份存储**，通常是足够大的快速磁盘，并提供对这些内存映像直接访问
* 为了有效使用CPU，需**每个进程的执行时间比交换时间长**，而且影响交换时间的主要是转移时间，**转移时间与所交换的内存空间成正比**。
* 如果换出进程，则必须确保该进程是完全处于空闲状态。
* 交换空间作为磁盘的一整块，而且独立于文件系统，使用可能较快
* 交换通常在**有许多进程运行且内存空间吃紧时启动**，在系统负荷降低时暂停

交换技术主要在**不同进程之间进行**，而覆盖则用于**同一进程中**。交换技术较为常用，覆盖技术已经基本成为历史。**采用覆盖和交换的目的都是节省主存空间。**对外存对换区的管理以**提高换入换出速度**为主要目标。

在**进程进行I/O操作时不能将其换出主存**，否则它的I/O数据区将会被新换入的进程占用，导致错误。不过可以在系统外存中开辟I/O缓冲区，将I/O活动的结果都放在外设缓冲区中。

### 0x01 连续分配管理方式

连续分配方式，是指为一个用户程序分配一个**连续的内存空间**。就比如说进程要1G的内存就给他分配1G的连续内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。

#### 0x00 单一连续分配

内存在此方式下分为**系统区和用户区**：

* 系统区仅提供给操作系统使用，通常在低地址部分
* 用户区是为用户提供的、除系统区之外的内存空间

这种方式无需进行内存保护。因为内存中**永远只有一道程序**（不适用于多道程序设计系统）。这种方式的优点是**简单、无外部碎片**，可以釆用覆盖技术，不需要额外的技术支持。缺点是**只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低**。

#### 0x01 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式，它**将用户内存空间划分为若干个固定大小的区域**，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。

![](https://bucket.shaoqunliu.cn/image/0211.png)

固定分区分配在划分分区时，有两种不同的方法，如上图所示。

- 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，**缺乏灵活性**
- 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。

为便于内存分配，通常将分区按大小排队，并为之建立一张**分区说明表**，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为“已分配”。未找到合适分区则拒绝为该用户程序分配内存。

这种分区方式存在两个问题：

* 程序可能太大放不进任何一个分区中，用户不得不使用**覆盖技术**来使用内存空间
* **主存利用率低**，当程序小于固定分区大小时，但也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为**内部碎片**

固定分区是可用于多道程序设计最简单的存储分配，**无外部碎片**，但**不能实现多进程共享一个主存区**，所以存储空间利用率低。

#### 0x02 动态分区分配

动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程**装入**内存时（不是创建进程时），**根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要**。因此系统中分区的大小和数目是可变的。

![](https://bucket.shaoqunliu.cn/image/0212.png)

如上图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2，操作系统就换出进程1，换入进程2。

动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，**内存中会产生越来越多的碎片**，内存的利用率随之下降。这些小的内存块称为**外部碎片**，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。**克服外部碎片可以通过紧凑技术来解决**，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。

在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略：

- 首次适应(First Fit)算法：空闲分区以**地址递增**的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区
- 最佳适应(Best Fit)算法：空闲分区按**容量递增**形成分区链，找到第一个能满足要求的空闲分区
- 最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以**容量递减**的次序链接，找到第一个能满足要求的空闲分区，也就是**挑选出最大的分区**。
- 邻近适应(Next Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是**分配内存时从上次查找结束的位置开始继续查找**。

在这几种方法中，**首次适应算法往往是最简单的、最好和最快的**。在UNIX 系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组来实现。不过，**首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销**。

邻近适应算法试图解决这个问题，但实际上，它常常会导致在**内存的末尾分配空间**，分裂成小碎片。它通常比首次适应算法的结果要差。

最佳适应算法虽然称为“最佳”，**但是性能通常很差**，因为**每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片**。

最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，**因此性能也非常差**。

首次适应算法可能比最佳适应算法好，其两者一定比最大适应算法好。

### 0x02 非连续分配管理方式

非连续分配允许一个程序分散地装入到不相邻的内存分区中，在连续分配中，即使内存有超过1G的剩余空间但是没有超过1G的**连续**剩余空间，进程也是无法运行的，但如果采用非连续分配的管理方式，作业所要求的内存空间可以分散地分配在内存的各个区域，当然，这也**需要额外的空间去存储他们的索引**。

非连续分配管理方式根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。

#### 0x00 基本分页存储管理方式

固定分区会产生**内部碎片**，动态分区会产生**外部碎片**，这两种技术的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：**把主存空间划分为大小相等且固定的块**，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，**以块为单位逐个申请主存中的块空间**。

分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：**块的大小相对分区要小很多**，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样**进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片**。所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，**每个进程平均只产生半个块大小的内部碎片**（也称**页内碎片**）。

分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能，且分页通过硬件机制实现，**对用户完全透明**。

##### 0x00 基本概念

* 页面和页面大小：**进程中的块称为页**（Page），**内存中的块称为页帧**（Page Frame，或页框）。外存也以同样的单位进行划分，直接称为块（Block），进程在执行时需要申请主存空间，就是要**为每个页面分配主存中的可用页帧**，这就产生了**页和页帧的一一对应**。
  为方便地址转换，**页面大小应是2的整数幂**。同时页面大小应该适中，**页面太小会使进程的页面数过多，页表过长占用大量内存，而且会增加硬件地址转换的开销，降低页面换入/换出的效率。页面太大又会使页内碎片增大，降低内存的利用率。**
* 地址结构，逻辑地址结构如下图：
  ![](https://bucket.shaoqunliu.cn/image/0213.png)
  前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0~11位为页内地址，即每页大小为$2^{12}\text{B}=4096\text{B}=4\text{KB}$，12~31位为页号，即地址空间最多允许有$2^{20}$页。
* 页表：为了便于在内存中找到进程的每个页面所对应的物理块，**系统为每个进程建立一张页表，记录页面在内存中对应的物理块号**，**一般存放在内存中**。进程执行时，通过查找页表即可找到每页在内存中的物理块号。其作用是实现从页号到物理块号的地址映射，如下图：
  ![](https://bucket.shaoqunliu.cn/image/0214.png)

##### 0x01 基本地址变换机构

地址变换机构的任务是**将逻辑地址转换为内存中物理地址**，地址变换是借助于页表实现的。在系统中通常设置一个页表寄存器（PTR）存放页表在内存中的起始地址F和页表长度M。**进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器**。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

* 计算页号$P=\frac{A}{L}$和页内偏移量$W=A \text{ mod } L$
* 比较页号P和页表长度M，若$P \geqslant M$，则产生**越界中断**，否则继续执行
* $页号P对应的页表项地址=页表起始地址F+页号P \times 页表项长度$，取出该页表项的内容b（物理块号）
* 物理地址E即为$E=b\times L+W$

如图：

![](https://bucket.shaoqunliu.cn/image/0219.png)

以上整个地址变换过程均是由硬件自动完成的。

例如，若页面大小L为1K字节，页号2对应的物理块为$b=8$，计算逻辑地址$A=2500$的物理地址E的过程如下：
$$
页面大小: L=1\text{K}=1024\text{B} \\
页号:P=\frac{2500}{1024}=2 \\
页面偏移量:W=2500 \text{ mod } 1024 = 452 \\
页号P=2对应的物理块为b=8 \\
\Rightarrow E=b\times L+W=8\times 1024+452=8644
$$
页表项的大小也不是随便规定的，而是要通过一定的规则计算的：

以32位逻辑地址空间为例，32位逻辑地址空间一共可以寻址的大小为$2^{32}$B，如果一页有4KB那么地址空间含有$\frac{2^{32}}{4 \times 1024}=1\text{M}$页，则需要$\log_2{1\text{M}}=20$位才能保证所表示范围能容纳所有的页面，又因为以字节作为编址单位，即页表项的大小需要$\geqslant \lceil \frac{20}{8} \rceil=3\text{B}$

分页管理方式存在的两个主要问题：

- 每次访存操作都需要进行逻辑地址到物理地址的转换，**地址转换过程必须足够快，否则访存速度会降低**
- 每个进程引入了页表用于存储映射机制，**页表不能太大否则内存利用率会降低**

##### 0x02 具有快表的地址变换机构

若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定所存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。

为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器即**快表**，又称联想寄存器（**TLB**），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表也常称为慢表。

在具有快表的分页机制中，地址变换的过程即为：

- CPU给出逻辑地址后，由硬件进行地址转换为页号，并将其送入高速缓存寄存器，**并将此页号与快表中的所有页号进行比较**。
- 如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的**页帧号**，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。
- 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

如图：

![](https://bucket.shaoqunliu.cn/image/0218.png)

> 注：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。

一般快表的命中率可以达到90%以上，这样分页带来的速度损失就降低到10%以下。快表的有效性是基于**局部性原理**。

##### 0X03 两级页表

由于引入了分页管理，进程在执行时不需要将所有页调入内存页帧中，而只要将保存有映射关系的页表调入内存中即可。但是我们仍然需要考虑页表的大小。以32 位逻辑地址空间、页面大小4KB、页表项大小4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要$2^{20}=1\text{M}$个页表项。也就是说，每个进程仅页表这一项就需要$4\text{B}\times 1\text{M}=4\text{MB}$的主存空间，这显然是不切实际的。而即便不考虑对全部逻辑地址空间进行映射的情况，一个逻辑地址空间稍大的进程，其页表大小也可能是过大的。以一个40MB的进程为例，页表项共40KB,如果将所有页表项内容保存在内存中，那么需要10个内存页帧来保存整个页表。整个进程大小约为1万个页面，而实际执行时只需要几十个页面进入内存页帧就可以运行，但如果要求10个页面大小的页表必须全部进入内存，这相对实际执行时的几十个进程页面的大小来说，肯定是降低了内存利用率的。从另一方面来说，这10页的页表项也并不需要同时保存在内存中，因为大多数情况下，映射所需要的页表项都在页表的同一个页面中。将页表映射的思想进一步延伸，就可以得到二级分页：将页表的10页空间也进行地址映射，建立上一级页表，**用于存储页表之间的映射关系**。这里对页表的10个页面进行映射只需要10个页表项，所以上一级页表只需要1页就足够（页面大小为4KB，页表项大小为4B那么1页就可以存储1024个页表项）。在进程执行时，只需要将这一页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再调入内存。

**为了查询方便，顶级页表往往最多只能有1个页面**。

#### 0x01 基本分段存储管理方式

##### 0x00 分段

段式管理方式**按照用户进程中的自然段**划分逻辑空间，**有利于程序的动态链接**，例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（**段内要求连续，段间不要求连续**，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。

如下图为分段系统中的**逻辑地址结构**：

![](https://bucket.shaoqunliu.cn/image/0215.png)

段号为16位，段内偏移量为16位，则一个作业最多可有$2^{16}=65536$个段，最大段长为$2^{16}\text{B}=65536\text{B}=64\text{KB}$。在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，**段号和段内偏移量必须由用户显式提供**，在髙级程序设计语言中，**这个工作由编译程序完成**。

##### 0x01 段表

每个进程都有一张逻辑空间与内存空间映射的段表，其中**每一个段表项对应进程的一个段**，**段表项记录该段在内存中的起始地址和段的长度**。

在配置了段表后，执行中的进程可通过查找段表，**找到每个段所对应的内存区**。可见，段表用于实现**从逻辑段到物理内存区的映射**，如下图：

![](https://bucket.shaoqunliu.cn/image/0216.png)

##### 0x02 地址变换机构

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：

- 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W
- 比较段号S和段表长度M，若$S\geqslant M$，即段号大于段表的长度，则产生越界中断，否则继续执行
- $段号S对应的段表项地址 = 段表起始地址F + 段号S \times 段表项长度$，找到段表项之后，取出该段表项的前几位得到段长C。若段内偏移量$W\geqslant C$，则产生越界中断，否则继续执行
- 取出段表项中该段的起始地址b，计算$E = b + W$，即可得到物理地址E

如图：

![](https://bucket.shaoqunliu.cn/image/0217.png)

##### 0x03 段的共享与保护

在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。**不能修改的代码称为纯代码或可重入代码**（它**不属于临界资源**），**这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享**。

与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断。再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。

与页式管理不同，段式管理不能仅仅给出一个整数就可以确定出其对应的物理地址，这是因为每段的长度是不固定的，不能通过整数除法得出段号，通过求余得到段内偏移，所以段号和段内偏移要显式给出，因此**分段管理的地址空间是二维的**。

#### 0x02 段页式管理方式

页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种方法结合起来，就形成了段页式存储管理方式。

在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，如图：

![](https://bucket.shaoqunliu.cn/image/0220.png)

在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图：

![](https://bucket.shaoqunliu.cn/image/0221.png)

为了实现地址变换，**系统为每个进程建立一张段表，而每个分段有一张页表**。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。

> 注
>
> 在**一个进程中，段表只有一个，而页表可能有多个**。且**段页式管理的地址空间也是二维的**。

在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。**进行一次访问实际需要三次访问主存**，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。  

![](https://bucket.shaoqunliu.cn/image/0222.png)

### 0x03 几种分配方式的比较

|   方式   | 覆盖技术 | 内部碎片 | 外部碎片 | 内存访问次数 |
| :------: | :------: | :------: | :------: | :----------: |
| 单道连续 |    √     |    √     |    ×     |      -       |
| 固定分区 |    √     |    √     |    ×     |      -       |
| 可变分区 |    ×     |    ×     |    √     |      -       |
|   页式   |    ×     |    √     |    ×     |      2       |
|   段式   |    ×     |    ×     |    √     |      2       |
|  段页式  |    ×     |    √     |    ×     |      3       |

> 可变分区又名动态分区
>
> 内存访问次数指从内存中取一次数据CPU访问内存的次数，指的都是在没有快表的情况下

* 上表中前三者为连续型后三者为离散型
* 操作系统实现**固定分区**时，代价最小
* 单一连续分配方式不适用于多道程序系统，因为在此方式中，内存中永远只有一道程序
* 单一连续分配方式不需要内存保护
* 对主存的访问以**字或字节为单位**，上面说的都是主存的分配方式
* **分页存储的地址结构是一维的**，即单一线性地址空间，**分段存储的地址结构是二维的**，因为段长是不固定的，既要给出段名又要给出段内地址
* **只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片**，如果固定和不固定同时存在，那么看成固定的（如段页式）。分页虚拟存储管理，每一页的长度都一样（对应固定），所以会产生内部碎片。分段式虚拟存储管理，每一段的长度都不一样（对应不固定），所有会产生外部碎片。

### 0x04 虚拟内存管理


#### 0x00 传统存储方式的特征

上文所述的内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计，往往具有如下几个特征：

* 一次性：作业必需一次性全部装入内存后才能开始运行，这会导致2种情况发生：第一，当作业很大，不能全部被装入内存时，将使该作业无法运行，第二，当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降
* 驻留性：作业被装入内存后，就一直驻留在内存中，其**任何部分**都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，而且可能处于长期等待状态。

许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。

#### 0x01 局部性原理

快表、页高速缓存以及虚拟内存技术从广义上讲都属于**高速缓存技术**。这个技术所依赖的原理就是局部性原理。**局部性原理既适用于程序结构，也适用于数据结构**（更远地讲，Dijkstra 著名的关于“`goto`语句有害”的论文也是出于对程序局部性原理的深刻认识和理解）。

局部性原理表现在如下的两个方面：

* **时间局部性**：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于**在程序中存在着大量的循环操作**。
* **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，**即程序在一段时间内所访问的地址，可能集中在一定的范围之内**，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

**时间局部性**是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。**空间局部性**通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。 

#### 0x02 虚拟存储器

基于局部性原理，在程序装入时，**可以将程序的一部分装入内存，而将其余部分留在外存**，就可以启动程序执行。在程序执行过程中，**当所访问的信息不在内存时，由操作系统将所需要的部分调入内存**，然后继续执行程序。另一方面，操作系统**将内存中暂时不使用的内容换出到外存上**，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为**虚拟存储器**。

**从内存中调入和调出页或段的基本手段是覆盖和交换**。

虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟存储器有以下三个主要特征：

* **多次性**：是指**无需在作业运行时一次性地全部装入内存**，而是允许被分成多次调入内存运行。
* **对换性**：是指**无需在作业运行时一直常驻内存**，而是允许在作业的运行过程中，进行换进和换出。
* **虚拟性**：是指**从逻辑上扩充内存的容量**，使用户所看到的内存容量，远大于实际的内存容量。

当内存釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，**虚拟内存建立在离散分配的内存管理方式的基础上**。虚拟内存的实现有以下三种方式：

* **请求分页**存储管理
* **请求分段**存储管理
* **请求段页式**存储管理

不管哪种方式，**都需要有一定的硬件支持**。一般需要的支持有以下几个方面：

* 一定容量的**内存和外存**
* **页表机制（或段表机制）**作为主要的数据结构
* **(缺页）中断机构**，当用户程序要访问的部分尚未调入内存，则产生中断
* **地址变换机构**，逻辑地址到物理地址的变换

### 0x05 请求分页管理方式

请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是**目前最常用的**一种实现虚拟存储器的方法。在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，通过调页功能将其调入，还可以通过置换功能将暂时不用的页面换出到外存上，以腾出内存空间。

#### 0x00 页表机制

请求分页系统的页表机制不同于基本分页系统，**请求分页系统在一个作业运行之前不要求全部一次性调入内存（间接地扩充了内存）**，因此在作业的运行过程中，必然会出现要访问的页面不在内存的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了四个字段，如图：

![](https://bucket.shaoqunliu.cn/image/0223.png)

其中：

* **状态位P（合法位）**：用于**指示该页是否已调入内存**，**供程序访问时参考**
* **访问字段A**：用于**记录本页在一段时间内被访问的次数**，或记录本页最近己有多长时间未被访问，**供置换算法换出页面时参考**
* **修改位M**：标识该页在**调入内存后是否被修改过**
* **外存地址**：用于**指出该页在外存上的地址**，通常是**物理块号**，供**调入该页时参考**

#### 0x01 缺页中断机构

在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒），如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：

* 在**指令执行期间**产生和处理中断信号，而非一条指令执行完后，属于**内部中断**
* 一条指令在执行期间，可能产生多次缺页中断

#### 0x02 地址变换机构

请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的：

![](https://bucket.shaoqunliu.cn/image/0224.png)

在进行地址变换时，**先检索快表**，若找到便修**改页表项中的访问位**（写指令还必需重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址。若未找到该页的页表项应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。

#### 0x03 页面置换算法

进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。选择调出页面的算法就称为页面置换算法，一般有如下4种页面置换算法：

* **最佳置换算法（OPT）**：所选择的被淘汰页面将是以后永不使用的，或者是**在最长时间内不再被访问的页面**，这样可以保证获得最低的缺页率

* **先进先出页面置换算法（FIFO）**：**优先淘汰最早进入内存的页面**，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面
  **FIFO算法还好产生当所分配的物理块数增大而页故障数不减反增的异常现象**，称之为`Belady`异常，**其他算法则不会出现这类异常**

* **最近最久未使用置换算法（LRU）**：选择**最近最长时间未访问过的页面**予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。此算法**性能最接近于OPT**，但实现起来较为困难（因为需要对过去多长时间未访问一个页面的时间进行**排序**选择最长时间未被访问过的那一个），且开销大

* **时钟置换算法（CLOCK）**：简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1，当页被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。**当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0**，如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换。如果所有帧的使用位均为1，则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用（Not Recently Used, NRU）算法
  **时钟置换算法性能较为接近LRU算法**，而且通过增加使用的位数目，可以使其更加高效，在使用位的基础上再增加一个修改位，则得到改进型的CLOCK算法，这样每一帧都处于以下四种情况之一：

  * 最近未被访问，也未被修改（u=0, m=0）
  * 最近被访问，但未被修改（u=1, m=0）
  * 最近未被访问，但被修改（u=0, m=1）
  * 最近被访问，被修改（u=1, m=1）

  此时算法执行的步骤为：

  * 从指针的当前位置开始，扫描帧缓冲区，在这次扫描过程中，**对使用位不做任何修改**。**选择遇到的第一个帧(u=0, m=0)用于替换**
  * 如果第1步失败，则重新扫描，**选择遇到的第一个(u=0, m=1)的帧用于替换**。在这次扫描过程中，**对每个跳过的帧把它的使用位设置成0**
  * 如果第2步失败，指针回到它的初始位置，并且此时集合中所有帧的使用位均为0，重复第1步，并且如果有必要重复第2步，这样将可以找到供替换的帧

  故：上述**四类帧的淘汰顺序**为：
  (u=0, m=0)->(u=0, m=1)->(u=1, m=0)->(u=1, m=1)

  依次为：第一步，第二步，第二步过后将每个跳过的帧的使用位u均设为了0（原先为1的也变为了0），使用位全部变为0之后的第二步

#### 0x04 页面分配策略

##### 0x00 驻留集大小

对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页，也就是说，给特定的进程分配多大的主存空间，则需要考虑如下几点：

* 分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率
* 如果一个进程在主存中的页数过少，尽管有局部性原理，**页错误率仍相对较高**
* 如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间**对该进程的错误率没有明显的影响**

基于这些因素，现代操作系统通常釆用三种策略：

* **固定分配局部置换**：为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略**难以确定为每个进程应分配的物理块数目**，太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降
* **可变分配全局置换**：这是**最易于实现的物理块分配和置换策略**，为系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中
* **可变分配局部置换**：为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度，反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块

综上，局部置换的意思就是当进程发生缺页的时候，只允许从该进程的内存页面中选一页换出。全局置换的意思就是其可以在系统空闲物理块队列中取出一块。固定分配就是为每个进程分配数量固定的物理块，且在运行期间均不改变。可变分配的意思也对应全局置换，当出现缺页时，就会从系统队列中取出一块用于扩展当前进程的页面的长度，所以为可变分配。

##### 0x01 调入页面的时机

* **预调页策略**：根据局部性原理，**一次调入若干个相邻的页可能会比一次调入一页更高效**。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用**以预测为基础的预调页策略**，将预计在不久之后便会被访问的页面预先调入内存，但目前预调页的成功率仅约50%，故**这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页**
* **请求调页策略**：进程在运行中需要访问的页面不在内存而提出请求，**由系统将所需页面调入内存**。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略，它的**缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销**

预调页实际上就是在运行前调入，请求调页实际上就是在运行期间调入。

##### 0x02 从何处调入页面

请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。**对换区通常是釆用连续分配方式，而文件区釆用离散分配方式**，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：

* 系统拥有足够的对换区空间：**可以全部从对换区调入所需页面，以提髙调页速度**。为此在进程运行前需要将与该进程有关的文件从文件区复制到对换区
* 系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入，而当换出这些页面时，由于它们未被修改而不必再将它们换出。但**对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入**
* UNIX方式：与进程有关的文件都放在文件区，**故未运行过的页面，都应从文件区调入**。**曾经运行过但又被换出的页面，放在对换区**，因此下次调入时直接对换区调入，进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入

##### 0x03 页面抖动和工作集

在页面置换过程中的一种最糟糕的情形是，**刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存**，这种频繁的页面调度行为称为**抖动**（颠簸）。如果**一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸**。

频繁的发生缺页中断（抖动），其**主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目**。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 

**所有的页面置换策略都有可能引起抖动**。当发生抖动时，可采取的有效措施**仅有撤销部分进程**。

工作集（驻留集）是**指在某段时间间隔内，进程要访问的页面集合**。**经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃**。为了防止系统出现抖动现象，需要选择合适的工作集大小。

让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。**如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象**。

工作集中**包含了所有最近k次（窗口大小）内存访问所访问过的页面**，怎么理解呢，看如下例子，这是一个进程所访问的页面序列：

```
1 2 5 8 6 0 3 2 3 2 |
```

若工作集的窗口大小为6，则在|所指示位置处，最近6次访问的页面为`6 0 3 2 3 2`，去除重复的页面后，此时工作集为`6 0 3 2`。